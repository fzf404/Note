<!-- 
title: 03-登录注册开发
sort: 
--> 

## 实现登录

> 使用bctypt验证密码hash值

```go
func Login(ctx *gin.Context) {
	DB := database.GetDB()
	name := ctx.PostForm("name")
	password := ctx.PostForm("password")
	log.Print(name, password)
	// 数据处理
	var user model.User
	DB.Where("name = ?", name).First(&user)
	if user.ID == 0 {
		ctx.JSON(422, gin.H{
			"code": 422, "msg": "用户名不存在",
		})
		return
	}
	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
		ctx.JSON(400, gin.H{
			"code": 400, "msg": "密码错误",
		})
		return
	}

	token := "Login Success"

	ctx.JSON(200, gin.H{
		"code": 200,
		"data": gin.H{"token": token},
		"msg":  "登录成功",
	})
}
```

## Token

> JWT生成解析Token

```go
package middleware

import (
	"time"

	"goLearn/model"

	"github.com/dgrijalva/jwt-go"
)

// token加密用的密钥
var jwtKey = []byte("fzf_secretca")

// 自定义有效载荷(这里采用自定义的Name和Email作为有效载荷的一部分)
type Claims struct {
	UserID uint
	jwt.StandardClaims
}

// 调用jwt-go库生成token
func ReleaseToken(user model.User) (string, error) {
	// 超时时间
	expirationTime := time.Now().Add(7 * 24 * time.Hour)
	claims := &Claims{
		UserID: user.ID,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: expirationTime.Unix(),
			IssuedAt:  time.Now().Unix(),
			Issuer:    "fzf404.top",
			Subject:   "user token",
		},
	}

	// 编码算法jwt.SigningMethodHS256, 返回token结构体指针
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    // 密钥加密token
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		return "", err
	}
	return tokenString, nil
}

// token解码
func ParseToken(tokenString string) (*jwt.Token, *Claims, error) {
	claims := &Claims{}
	var token *jwt.Token
	var err error
	// 自定义的Claims结构体 ,token ,自定义函数来解析token-return之前定义好的签名
	token, err = jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (i interface{}, err error) {
		return jwtKey, nil
	})

	return token, claims, err
}
```

## 验证Token

> 中间件验证Token

```go
package middleware

import (
	"net/http"
	"strings"

	"goLearn/database"
	"goLearn/model"

	"github.com/gin-gonic/gin"
)

// 返回处理函数
func AuthMiddleware() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		tokenString := ctx.GetHeader("Authorization")
		// 判断Bearer
		if tokenString == "" || !strings.HasPrefix(tokenString, "Bearer") {
			ctx.JSON(http.StatusUnauthorized, gin.H{
				"code": 401, "msg": "Token验证失败",
			})
			ctx.Abort()
			return
		}
		// 调用解析函数
		tokenString = tokenString[7:]
		token, Claims, err := ParseToken(tokenString)

		// 判断token是否有效
		if err != nil || !token.Valid {
			ctx.JSON(http.StatusUnauthorized, gin.H{
				"code": 401, "msg": "Token失效，请重新登录", "data": err,
			})
			ctx.Abort()
			return
		}
		// 数据库查表
		userId := Claims.UserID
		DB := database.GetDB()
		var user model.User
		DB.First(&user, userId)
		if user.ID == 0 {
			ctx.JSON(http.StatusUnauthorized, gin.H{
				"code": 401, "msg": "用户不存在",
			})
			ctx.Abort()
			return
		}
		// 用户存在 写入上下文
		ctx.Set("user", user)
		ctx.Set("name", user.Name)
		ctx.Next()
	}
}
```

## 独立配置文件

> `config.go`

```go
package config

import (
	"os"

	"github.com/spf13/viper"
)

func InitConfig() {
	// 当前路径
	workDir, _ := os.Getwd()
	// config信息
	viper.SetConfigName("config")
	viper.SetConfigType("yml")
	viper.AddConfigPath(workDir + "/config")
	// 读取
	err := viper.ReadInConfig()
	if err != nil {
		panic(err)
	}
}
```