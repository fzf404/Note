(window.webpackJsonp=window.webpackJsonp||[]).push([[229],{857:function(n,t){n.exports='\x3c!--\ntitle: 02-Java基础\nsort:\n--\x3e\n\n## 数据类型\n\n> 占用字节数\n\n```\n       ┌───┐\n  byte │   │\n       └───┘\n       ┌───┬───┐\n short │   │   │\n       └───┴───┘\n       ┌───┬───┬───┬───┐\n   int │   │   │   │   │\n       └───┴───┴───┴───┘\n       ┌───┬───┬───┬───┬───┬───┬───┬───┐\n  long │   │   │   │   │   │   │   │   │\n       └───┴───┴───┴───┴───┴───┴───┴───┘\n       ┌───┬───┬───┬───┐\n float │   │   │   │   │\n       └───┴───┴───┴───┘\n       ┌───┬───┬───┬───┬───┬───┬───┬───┐\ndouble │   │   │   │   │   │   │   │   │\n       └───┴───┴───┴───┴───┴───┴───┴───┘\n       ┌───┬───┐\n  char │   │   │\n       └───┴───┘\n```\n\n### 引用类型\n\n> 内部存储地址,指向对象的位置\n\n```java\nString s = "hello";\ns.equals(arg)\t// 判断是否相等\n// PI是一个常量\nfinal double PI = 3.14;\n// 类型名字太长\nvar sb = new StringBuilder();\n// 强制类型转换\nint i = 12345;\nshort s = (short) i; // 12345\n```\n\n### 数组\n\n```java\nint[] array = new int[5];\nint[] array2 = { 1, 2, 3, 4, 5 };\n\narray.length();\n// 数组转String\nString.valueOf(array)\n// 字符串转数组\nstr.toCharArray();\n// 对象转换为字符串\nobject.toString();\n// 数组排序\narray.sort()\n```\n\n## 读取输入\n\n```java\nimport java.util.Scanner;\nScanner s = new Scanner(System.in);\nString name = s.nextLine();\nint age = s.nextInt();\n```\n\n## 流程控制\n\n```java\nif() {\n} else if() {\n}else{\n}\n// switch\nswitch (i){\n\tcase 1 -> Statement;\n  case 2:\n\t\tStatement;\n\t\tbreak;\n\tdefault -> {\n    Statement1;\n    Statement2;\n  }\n}\n// 遍历for循环\nint[] array = { 1, 4, 9, 16, 25 };\nfor (int n : array) {\n  System.out.println(n);\n}\n```\n\n## 面向对象\n\n```java\nclass Friend {\n  // 属性\n  public String name;\n  public int age;\n  private double relation;\t\t\t\t\t// 子类实例均无法调用\n  protected double relationship;\t\t// 子类可继承,实例无法调用\n\n\t// 构造方法\n  public Friend(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n  public void sayInfo() {\n    System.out.println("Name: " + this.name + "\\nAge: " + this.age + "\\nPercent: " + this.relationship);\n  }\n}\n// 子类继承Friend\nclass Son extends Friend {\n  public Son(String name, int age) {\n    // 调用父类构造函数\n    super(name, age);\n  }\n  public void hi() {\n    System.out.println("hi~");\n  }\n}\n\n// 主类\npublic class Hello {\n  public static void main(String[] args) {\n    var oneSon = new Son("小明之子", 18);\n    oneSon.sayInfo();\n    Friend f1 = new Son("小明之子", 18);\n    if (f1 instanceof Son) {\n      var f2 = (Son) f1;\n      f2.hi();\n    }\n  }\n}\n\n@Override\t\t\t\t\t// 覆写父类方法时判断是否正确签名\nsuper.method();\t\t// 调用父类覆写的方法\npublic final void method(){}\t\t// 不可被子类覆写\n\n// 父类的方法被全部子类覆写,则可定义抽象方法\nabstract class Friend {\n\tpublic abstract void methos(int args);\n}\nclass Son extends Friend {\n  public double rela;\n\tpublic void setRel(double rel) {\n    this.rela=rel;\n  }\n}\n\n// 全部方法都是抽象的,可定义接口\nabstract class Person {\n    public abstract void run();\n    public abstract String getName();\n}\ninterface Person{\n  void run();\n  String getName();\n}\n// class实现interface须使用implements\nclass Student implements Person {}\n```\n\n## 泛型\n\n> `ArrayList`使用泛型新建`StringList`对象\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n      \t//  List<String> list = List.of("apple", "pear", "banana")\n        list.add("apple"); // size=1\n        list.add("pear"); // size=2\n        list.add("apple"); // 允许重复添加元素，size=3\n        System.out.println(list.size());\n    }\n}\n```\n\n## 迭代器\n\n> 使用迭代器访问 LIst 效率最高\n\n```java\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of("apple", "pear", "banana");\n        for (Iterator<String> it = list.iterator(); it.hasNext(); ) {\n            String s = it.next();\n            System.out.println(s);\n        }\n    }\n}\n```\n\n## 异常捕获\n\n```java\npublic static void main(String[] args) {\n    try {\n      \t// 断言 不满足则抛出异常\n      \tassert process1() > 0;\n      \tprocess2();\n    } catch (UnsupportedEncodingException e) {\n      \t// 打印调用栈\n      \tprintStackTrace();\n\t\t\t\tthrow new RuntimeException("Bad encoding");\n    } catch (IOException e) {\n        System.out.println("IO error");\n    } finally {\n        System.out.println("END");\n    }\n}\n```\n'}}]);