(window.webpackJsonp=window.webpackJsonp||[]).push([[228],{856:function(n,t){n.exports='\x3c!--\ntitle: 01-Java快速入门\nsort:\n--\x3e\n\n> [refer_1](https://blog.csdn.net/yhsnihao/article/details/88697660) [refer_2](https://blog.csdn.net/qq_30993595/article/details/81951361)\n\n## JAVA 基础\n\n> 面向对象\n>\n> 编译器将每一个 class 编译成相应名称的`.class`字节码文件。\n\n## 特性\n\n- 自动回收内存\n\n  `System.gc();`\n\n## 关键字\n\n- `static`\n\n  > 无论一个类实例化多少对象，它的静态变量只有一份拷贝。\n  >\n  > `main()`方法是静态的，执行时不会创建所在类的实例对象\n\n- `final`\n\n  > 指向变量的指针不可修改\n\n### 变量\n\n> 函数中变量分配栈内存，调用结束后自动释放。\n>\n> `new`定义的对象或数组分配堆内存，由 java 虚拟机自动回收\n\n```java\n// 数组不可指定大小\nint i[] = {1,2,3,4};\nint i[] = new x[num];\nint i[] = new x[]{1,2,3,4};\n// 多维数组\n// 本质是数组中的数组\nint x[][];\nx = new int[3][];\nx[0] = new int[3];\nx[1] = new int[2];\n// x[2]未赋值，指向null\n```\n\n## 基础语句\n\n```java\n// 高级for循环\nint for_array[] = { 2, 3, 5, 7, 11 };\nfor (int num : for_array) {\n    System.out.println(num);\n}\n// 三目运算\n(a>b)?c:d;\n```\n\n### 枚举\n\n```java\nclass FreshJuice {\n   enum FreshJuiceSize{ SMALL, MEDIUM , LARGE }\n   FreshJuiceSize size;\n}\n\npublic class FreshJuiceTest {\n   public static void main(String[] args){\n      FreshJuice juice = new FreshJuice();\n      juice.size = FreshJuice.FreshJuiceSize.MEDIUM;\n   }\n}\n```\n\n## 面向对象\n\n### 函数重载\n\n### 构造函数\n\n> 无返回值，创建实例时执行初始化\n\n```java\nimport java.util.*;\n\nclass demo{\n\tpublic static void main(String[] args) {\n\t\tTodo test1 = new Todo();\n\t\tTodo test2 = new Todo("admin");\n\t\tScanner sc = new Scanner(System.in);\n\t\tString name = sc.nextLine();\n\t\tTodo test3 = new Todo(name);\n\t}\n}\n\nclass Todo{\n\tprivate String name = "fzf404";\n\tprivate static String static_time = new Date().toString();\n\tprivate String time = new Date().toString();\n\tpublic Todo(){\n\t\tSystem.out.println("Welcom " + name);\n\t\tSystem.out.println("Static time:"+ static_time);\n\t\tSystem.out.println("now time:"+ time);\n\t}\n    // 函数重载\n\tpublic Todo(String name){\n\t\tthis.name = name;\n\t\tSystem.out.println("Welcom " + name);\n\t\tSystem.out.println("Static time:"+ static_time);\n\t\tSystem.out.println("now time:"+ time);\n\t}\n}\n/*\nWelcom fzf404\nStatic time:Thu Dec 10 09:12:40 CST 2020\nnow time:Thu Dec 10 09:12:40 CST 2020\n\nWelcom admin\nStatic time:Thu Dec 10 09:12:40 CST 2020\nnow time:Thu Dec 10 09:12:40 CST 2020\n\nguest\nWelcom guest\nStatic time:Thu Dec 10 09:12:40 CST 2020\nnow time:Thu Dec 10 09:12:43 CST 2020\n```\n\n### this\n\n> 指向对象在堆内存中的首地址\n\n```java\nclass A\n{\n\tpublic void fun1()\n\t{\n\t}\n\tpublic void fun2()\n\t{\n\t\tA a2 = new A();\n\t\t// 调用a2的func1()方法\n\t\ta2.fun1();\n\t\t// 调用实例的func()方法\n\t\tthis.fun1();\n\t}\n\n\tpublic static void main(String arg[])\t\t//main函数\n\t{\n\t\t// 实例化A类\n\t\tA a1 = new A();\n\t\t// 对象a1调用fun2()方法\n\t\ta1.fun2();\n\t}\n}\n```\n\n```java\nclass Person\n{\n\tprivate String name;\n\tpublic shout(String name)\n\t{\n\t\t// 对象的属性->方法中的局部变量\n\t\tthis.name=name;\n\t\tSystem.out.println("My name is "+name);\n\t}\n}\n```\n\n> 调用构造方法\n\n```java\nclass Test\n{\n\tpublic Test()\n\t{\n\t\tthis("function2");\n\t}\n\tpublic Test(String m)\n\t{\n\t\tSystem.out.println(m+" is running");\n\t}\n\n\tpublic static void main (String arg[])\n\t{\n\t\tTest t = new Test();\n\t}\n}\n/*\nfunction2 is running\n```\n\n### 对象的强制类型转换\n\n```java\nclass A\n{\n\tpublic void func1()\n\t{\n\t\tSystem.out.println("A func1 is calling");\n\t}\n\t\tpublic void func2()\n\t{\n\t\tSystem.out.println("A func2 is calling");\n\t}\n}\n\nclass B extends A\n{\n\tpublic void func1()\n\t{\n\t\tSystem.out.println("B func1 is calling");\n\t}\n\tpublic void func3()\n\t{\n\t\tSystem.out.println("B func3 is calling");\n\t}\n}\n\nclass Test\n{\n\tpublic static void main(String args[])\n\t{\n\t\tcallA(new B());\t\t\t//将类B传递给callA函数\n\t}\n\tpublic static void callA(A a)\t\t//函数接受一个类A的对象作为参数\n\t{\n\t\ta.func1();\n\t\ta.func2();\n\t}\n}\n/*\nB func1 is calling\nA func2 is calling\n```\n\n### 内部类\n\n> 使用`static`则成为同级类\n\n```java\nclass Outer\n{\n\tprivate int size;\n\tpublic class Inner\n\t{\n\t\tprivate int size;\n\t\tpublic void doStuff(int size)\n\t\t{\n\t\t\tsize++;\t\t\t\t//引用的是doStuff()函数的size\n\t\t\tthis.size++;\t\t//引用的是Inner类的size\n\t\t\tOuter.this.size++;\t//引用的是Outer类的size\n\t\t}\n\t}\n}\n// 引用\nclass demo\n{\n\tpublic static void main(String[] args) {\n\t\tOuter test = new Outer();\n\t\tOuter.Inner test_in = test.new Inner();\n\t}\n}\n```\n\n## 继承\n\n> `extends`\n>\n> 子类继承父类所有成员变量和方法\n>\n> JAVA 只支持单继承,但可多层继承\n\n### 子类的实例化\n\n```java\n// 父类\nclass Person\n{\n\tpublic String name = "unknow";\n\tpublic int age =-1;\n\tpublic Person()\n\t{\n\t}\n\tpublic Person(String name,int age)\n\t{\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\tvoid getInfo()\n\t{\n\t\tSystem.out.println(name);\n\t\tSystem.out.println(age);\n\t}\n}\n// 子类\nclass Student extends Person\n{\n\tpublic String school = "unknow";\n\tpublic Student()\n\t{\n        // 调用父类的构造方法\n\t\tsuper();\n\t}\n\tpublic Student(String name,int age)\n\t{\n\t\tsuper(name,age);\n\t}\n\tpublic Student(String name,int age,String school)\n\t{\n\t\tthis(namde,age);\n\n\t\tthis.school = school\n\t}\n}\nclass Test\n{\n\tpublic static void main(String args[])\n\t{\n\t\tStudent stu = new Student("DRF",20,"UESTC");\n\t\tstu.getInfo();\n\t}\n}\n```\n\n## 抽象类\n\n> 仅声明,没有方法的具体实现,交由子类重载\n\n```java\nabstract class Abstract {\n\tabstract int test(int x,String y);\n\tpublic Abstract{\n\t\tSystem.out.println("Abstract Construct Success!")\n\t}\n}\n```\n\n### 接口\n\n> 如果类中所有方法都是抽象的,可直接写为接口\n\n```java\nabstract class A\n{\n\tpublic static final int ID = 1;\n\tabstract int aa();\n\tabstract void bb();\n}\n```\n\n```java\ninterface A\n{\n\tint ID = 1;\n\tint aa();\n\tvoid bb();\n}\n```\n'}}]);