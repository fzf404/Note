(window.webpackJsonp=window.webpackJsonp||[]).push([[374],{1002:function(e,n){e.exports='\x3c!--\ntitle: Puppeteer\nsort:\n--\x3e\n\n> 爬虫框架-基于 Chrome\n>\n> [官方中文文档](https://zhaoqize.github.io/puppeteer-api-zh_CN/)\n\n## Nodejs\n\n```bash\nyarn add puppeteer\n# 不包含chromium\nyarn add puppeteer-core\n\n# ubuntu\napt install chromium-browser\n```\n\n> HelloWorld\n\n```js\nconst puppeteer = require("puppeteer");\n\n(async () => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.goto("https://example.com");\n  await page.screenshot({ path: "example.png" });\n  await browser.close();\n})();\n```\n\n### 更改配置\n\n```js\nconst puppeteer = require("puppeteer");\n\n(async () => {\n  // 显示浏览器窗体\n  const browser = await puppeteer.launch({ headless: false });\n  const page = await browser.newPage();\n  // 调整页面大小\n  await page.setViewport({ width: 1920, height: 1080 });\n  await page.goto("https://example.com");\n  await page.screenshot({ path: "example.png" });\n\n  await browser.close();\n})();\n```\n\n## 操作\n\n### 模拟用户操作\n\n- `elementHandle.click()`：点击某个元素\n- `elementHandle.tap()`：模拟手指触摸点击\n- `elementHandle.focus()`：聚焦到某个元素\n- `elementHandle.hover()`：鼠标 hover 到某个元素上\n- `elementHandle.type(\'hello\')`：在输入框输入文本\n- ``：获得值\n\n```js\nconst puppeteer = require("puppeteer");\n\n(async () => {\n  // 创建新浏览器\n  const browser = await puppeteer.launch({\n    headless: false,\n    defaultViewport: { width: 1280, height: 960 },\n    ignoreHTTPSErrors: false, // 忽略https报错\n    // args: [\'--start-fullscreen\']  // 全屏\n  });\n\n  const page = await browser.newPage();\n  await page.goto("https://www.baidu.com/");\n  \n  // 获得值\n  const code = await page.$eval(\'#code-box\', (el) => el.innerText)\n\n  const inputElement = await page.$("#kw");\n  // type 输入文本\n  await inputElement.type("hello world", { delay: 20 });\n\n  // 等待跳转\n  await page.waitForNavigation();\n  // 模拟按键\n  await page.keyboard.down("Enter");\n\n  // 点击进入\n  let searchElement = await page.$("#\\\\31 > h3 > a");\n\n  // 等待页面跳转完成，一般点击某个按钮需要跳转时，都需要等待 page.waitForNavigation() 执行完毕才表示跳转成功\n  await Promise.all([searchElement.click(), page.waitForNavigation()]);\n\n  await page.close();\n  await browser.close();\n})();\n```\n\n### 植入 JS\n\n> 浏览器内部执行代码\n\n- `page.evaluate(pageFunction[, ...args])`：在浏览器环境中执行函数\n- `page.evaluateHandle(pageFunction[, ...args])`：在浏览器环境中执行函数，返回 JsHandle 对象\n- `page.$$eval(selector, pageFunction[, ...args])`：把 selector 对应的所有元素传入到函数并在浏览器环境执行\n- `page.$eval(selector, pageFunction[, ...args])`：把 selector 对应的第一个元素传入到函数在浏览器环境执行\n- `page.evaluateOnNewDocument(pageFunction[, ...args])`：创建一个新的 Document 时在浏览器环境中执行，会在页面所有脚本执行之前执行\n- `page.exposeFunction(name, puppeteerFunction)`：在 window 对象上注册一个函数，这个函数在 Node 环境中执行，有机会在浏览器环境中调用 Node.js 相关函数库\n\n```js\nconst puppeteer = require("puppeteer");\n\n(async () => {\n  const browser = await puppeteer.launch({ headless: false });\n  const page = await browser.newPage();\n  await page.goto("https://www.baidu.com/");\n\n  // page.evaluate 在浏览器里执行代码\n  const resultData = await page.evaluate(async () => {\n    let data = {};\n    // 选择实时热榜\n    const ListEle = [\n      ...document.querySelectorAll("#hotsearch-content-wrapper > li"),\n    ];\n    data = ListEle.map((ele) => {\n      // 从li中筛出信息\n      const url = ele.querySelector("a.c-link");\n      const title = ele.querySelector(".title-content-title");\n      return {\n        href: url.href,\n        title: title.innerText,\n      };\n    });\n    return data;\n  });\n\n  console.log(resultData);\n  await page.close();\n  await browser.close();\n})();\n```\n\n### 生命周期\n\n- `page.on(\'close\')` 页面关闭\n- `page.on(\'console\')` console API 被调用\n- `page.on(\'error\')` 页面出错\n- `page.on(\'load\')` 页面加载完\n- `page.on(\'request\')` 收到请求\n- `page.on(\'requestfailed\')` 请求失败\n- `page.on(\'requestfinished\')` 请求成功\n- `page.on(\'response\')` 收到响应\n- `page.on(\'workercreated\')` 创建 webWorker\n- `page.on(\'workerdestroyed\')` 销毁 webWorker\n\n#### 请求拦截\n\n```js\nconst page = await browser.newPage();\n\n// 拦截没有必要的请求\nconst blockTypes = new Set(["image", "media", "font"]);\nawait page.setRequestInterception(true); //开启请求拦截\npage.on("request", (request) => {\n  const type = request.resourceType();\n  const shouldBlock = blockTypes.has(type);\n  if (shouldBlock) {\n    // 阻止请求\n    return request.abort();\n  } else {\n    // 请求重写\n    return request.continue({\n      // 可以对 url method postData headers 进行覆盖\n      headers: Object.assign({}, request.headers(), {\n        "puppeteer-test": "true",\n      }),\n    });\n  }\n});\n\nawait page.goto("https://www.baidu.com/");\n```\n\n### 上传下载\n\n```js\n// 通过 CDP 会话设置下载路径\nconst cdp = await page.target().createCDPSession();\nawait cdp.send("Page.setDownloadBehavior", {\n  behavior: "allow", // 允许所有下载请求\n  downloadPath: "D:", // 设置下载路径\n});\nawait (await page.waitForSelector("#someButton")).click();\n\n// 使用node下载文件\nconst http = require("http");\nconst fs = require("fs");\nhttp.request(url, (res) => {\n  res.pipe(fs.createWriteStream(path.basename(url)));\n});\n\n// 上传文件\nawait inputElement.uploadFile("/path/to/file");\n```\n\n### 模拟设备\n\n```js\nconst devices = puppeteer.devices["iPad Pro"];\nawait page.emulate(devices);\n\n// 获得支持设备json文件\nfs.writeFile("device.json", JSON.stringify(puppeteer.devices), (err) => {});\n```\n'}}]);