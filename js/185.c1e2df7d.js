(window.webpackJsonp=window.webpackJsonp||[]).push([[185],{813:function(n,r){n.exports="\x3c!--\ntitle: Arm汇编进阶\nsort:\n--\x3e\n\n## 条件状态和分支\n\n```assembly\n.global main\n\nmain:\n  mov     r0, #2     /* 初始化变量 */\n  cmp     r0, #3     /* 将R0中的值与3比较，负数位置1 */\n  addlt   r0, r0, #1 /* 如果上一条比较结果是小于（查看CPSR），则将R0加1 */\n  cmp     r0, #3     /* 将R0中的值再与3比较， 零位置1，同时负数位重置为0 */\n  addlt   r0, r0, #1 /* 如果上一条比较结果是小于（查看CPSR），则将R0加1 */\n  bx      lr\t\t\t\t\t@ 跳转到lr寄存器地址处，也就是子程序返回\n```\n\n### IT 指令\n\nIT：If-Then（下一条指令是条件的）；\n\nITT：If-Then-Then（后两条指令是条件的）；\n\nITE：If-Then-Else（后两条指令是条件的）；\n\nITTE：If-Then-Then-Else（后三条指令是条件的）；\n\nITTEE：If-Then-Then-Else-Else（后四条指令是条件的）；\n\n```assembly\n.syntax unified    @ 非常重要!\n.text\n.global _start\n\n_start:\n    .code 32\n    add r3, pc, #1   @ PC的值加1并存储到R3。\n    @ R3中的值最低有效位为1\n    bx r3            @ 切换到Thumb模式\n\n    .code 16         @ Thumb模式\n    cmp r0, #10\n    ite eq           @ 如果R0等于10...\n    addeq r1, #2     @ ... 那么 R1 = R1 + 2\n    addne r1, #3     @ ... 否则 R1 = R1 + 3\n    bkpt\n```\n\n### 分支\n\n```\n.global main\n​\nmain:\n  mov     r1, #2     /* 设置初始变量a */\n  mov     r2, #3     /* 设置初始变量b */\n  cmp     r1, r2     /* 比较两个变量值看哪个更大 */\n  blt     r1_lower   /* R2更大(N==1)，跳转到r1_lower */\n  mov     r0, r1     /* 没有跳转，将R1的值存储到R0 */\n  b       end        /* 结束 */\n\n r1_lower:\n  mov\t\t\tr0, r2     /* R1小于R2时跳转, R2的值存储到R0 */\n  b\t\t\t\tend        /* 结束 */\n\nend:\n  bx lr              /* THE END */\n```\n\n- 分支实现循环\n\n```assembly\n.global main\n​\nmain:\n        mov     r0, #0     /* 设置初始变量a */\nloop:\n        cmp     r0, #4     /* 比较a==4 */\n        beq     end        /* 如果a==4，结束 */\n        add     r0, r0, #1 /* 否则将R0中的值递增1 */\n        b loop             /* 跳转到loop开始位置 */\nend:\n        bx lr              /* THE END */\n```\n\n### B、BX、BLX 指令\n\n> B：直接跳转至函数\n>\n> BL：将 PC+4 的值保存到 LR 寄存器，然后跳转。\n>\n> BX、BLX 用来切换 ARM 模式到 Thumb 模式。\n\n## 栈和函数\n\n### 栈\n\n```assembly\n.text\n.global _start\n\n_start:\n     mov   r0, #2  /* 设置R0的初始值*/\n     push  {r0}    /* 将R0的值保存到栈*/\n     mov   r0, #3  /* 覆盖R0的值 */\n     pop   {r0}    /* 恢复R0的初始值 */\n     bx    lr      /* 结束程序 */\n\nas demo.s -o demo.o && ld demo.o -o demo && gdb -f demo\n\ngef> x/w $sp\n```\n\n### 函数\n\n```assembly\n@ 调用前准备\npush   {r11, lr}    /* 将lr和r11入栈 */\nadd    r11, sp, #0  /* 保存栈底地址 */\nsub    sp, sp, #16  /* 栈指针减去16为局部变量分配缓存区 */\n\n@ 函数体\nmov    r0, #1       /* 设置局部变量(a=1). 同时也为函数max的第一个参数 */\nmov    r1, #2       /* 设置局部变量(b=2). 同时也为函数max的第二个参数 */\nbl     max          /* 调用函数max */\n\n@ 离开函数\nsub    sp, r11, #0  /* 重新调整栈指针 */\npop    {r11, pc}    /* 恢复栈帧指针, 通过加载之前保存的LR到PC，程序跳转到之前LR保存位置。函数的栈帧被销毁 */\n```\n"}}]);