(window.webpackJsonp=window.webpackJsonp||[]).push([[276],{904:function(n,e){n.exports='\x3c!--\ntitle: 04-Python高级函数与装饰器\nsort:\n--\x3e\n\n## 高阶函数\n\n- `f=abs`函数可以赋值给变量。\n- `abs=10`函数名可以指向其他对象.\n- 高阶函数：接收另一个函数为参数\n\n### map/reduce()\n\n- `map()`函数接收两个参数，一个是函数，一个是`Iterable`。\n\n- `map`将传入的函数依次作用到序列的每个元素，并把结果作为新的`Iterator`返回。\n\n- `reduce`把一个函数作用在序列上。并把结果与下一个元素做累计计算。\n\n- ```python\n  from functools import reduce\n\n  l = [1, 4, 8, 20, 52]\n\n  def my_pow(i):\n      return i**2\n\n  def my_add(x, y):\n      return x+y\n\n  print(reduce(my_add, map(my_pow, l)))\n  ```\n\n### filter()\n\n- 根据返回值的`T/F`决定保留还是丢弃该元素。\n\n- 返回值是一个`Iterator`,需要用`list()`\n\n  ```python\n  def del_odd(i):\n      return i % 2 == 0\n\n  l = [1, 2, 3, 4, 5, 6]\n  print(list(filter(del_odd, l)))z\n  ```\n\n### sorted()\n\n- 排序函数\n\n- 可以根据`key`来决定排序方式。\n\n- 可以使用`reverse`参数进行反向排序。\n\n  ```python\n  example_list = [-4, -2, -1, 0, 3, 6]\n  print(sorted(example_list, key=lambda x: x*-1))\n  ```\n\n## 闭包\n\n- `return function`返回一个函数，下回调用时求值。\n\n- 即使传入相同参数，每次调用都返回一个新的函数。\n\n- **闭包**\n\n  > **将函数内的变量即内部函数`return`到外面**\n  >\n  > 返回函数不要引用任何循环变量，或者后续会发生变化的变量。\n  >\n  > 因为函数不会立即执行。除非创建新函数\n  >\n  > 否则所有变量都将为最终值。\n\n- 从函数中返回函数\n\n  ```python\n  def hi(name=\'fzf\'):\n      def admin():\n          return "hello admin"\n\n      def guest():\n          return "hello guset"\n      if name == \'fzf\':\n          return admin\n      else:\n          return guest\n\n\n  a = hi()\n  print(a())\n  ```\n\n- 装饰器\n\n  ```python\n  def hi(func, name=\'fzf\'):\t\t# 装饰函数\n      def admin():\n          print("hello admin")\n          func()\n          print("bye admin")\n\n      def guest():\n          print("hello %s" % name)\n          func()\n          print("bye %s" % name)\n\n      if name == \'fzf\':\n          return admin\n      else:\n          return guest\n\n\n  def opera():\n      print("i want to kill you!")\n\n\n  a = hi(opera, name="pig")\n  a()\n  ```\n\n- 使用`@`\n\n  ```python\n  def hi(func, name=\'fzf\'):\t\t# 装饰函数\n      def admin():\n          print("hello admin")\n          func()\n          print("bye admin")\n\n      def guest():\n          print("hello %s" % name)\n          func()\n          print("bye %s" % name)\n\n      if name == \'fzf\':\n          return admin\n      else:\n          return guest\n\n  @hi\n  def opera():\n      print("i want to kill you!")\n\n  opera()\n  ```\n\n- name\n\n  ```python\n  print(opera.__name__)\n  > admin\n  # 打印函数名发现名称变了\n  # 可使用wraps\n  from functools import wraps\n  def hi(func, name=\'fzf\'):\n      @wraps(func)\n      ...\n  ```\n\n- **最基础的闭包+装饰器：**\n\n```python\nfrom functools import wraps\n\n\ndef decorator_name(f):\n  @wraps(f)\n  def decorated(*args, **kwargs):\n      if not can_run:\n          return "Function will not run"\n      return f(*args, **kwargs)\t# 运行原函数\n  return decorated\t\t# 返回修饰好的函数\n\n\n@decorator_name\ndef func():\n  return("Function is running")\n\n\ncan_run = True\nprint(func())\n# Output: Function is running\n\ncan_run = False\nprint(func())\n# Output: Function will not run\n```\n\n- 高阶带参数\n\n  ```python\n  def log(name):\n      def hi(func):\t\t# 装饰函数\n          def admin():\n              print("hello admin")\n              func()\n              print("bye admin")\n\n          def guest():\n              print("hello %s" % name)\n              func()\n              print("bye %s" % name)\n\n          if name == \'fzf\':\n              return admin\n          else:\n              return guest\n     return hi\n\n\n  @log(\'pig\')\n  def opera():\n      print("i want to kill you!")\n\n  opera()\n  ```\n\n## 匿名函数\n\n- 匿名函数`lambda x: x * x`实际上就是：\n\n  ```python\n  def f(x):\n      return x * x\n  ```\n\n- 可以把一个匿名函数赋值给变量。\n\n  ```python\n  f = lambda x: x * x\n  ```\n\n## 装饰器\n\n> 装饰器必须满足函数是闭包\n\n- 在代码运行期间动态增加功能的方式。\n\n- ```python\n  def log(func):\t\t\t\t# decorator\n  \tdef wrapper(*args, **kw):\n  \t\tprint(\'call %s():\' % func.__name__)\n  \t\treturn func(*args, **kw)\n  \treturn wrapper\n\n  @log\t\t\t\t\t\t# 相当于：now = log(now(*))\n  def now(s):\n  \tprint(s + \'2020-3-10\')\n\n  now(\'现在时间：\')\n\n  >>>\n  call now()\n  现在时间：2020-3-10\n  ```\n\n- 只是将 now 函数名指向新的函数。\n\n- 假如 decorator 本身需要传入参数，需要编写返回 d 的高阶函数：\n\n- ```python\n  def log(text):\t\t# 多加一层\n      def decorator(func):\n          def wrapper(*args, **kw):\n              print(\'%s %s():\' % (text, func.__name__))\n              return func(*args, **kw)\n          return wrapper\n      return decorator\n\n  @log(\'execute\')\t\t\t\t# 相当于：now = log(\'execute\')(now)\n  def now():\n      print(\'2015-3-25\')\n\n  >>> now()\n  execute now():\n  2015-3-25\n  ```\n\n- 为了保留`func.__name__`属性，可使用`functools.wraps`函数。\n\n- ```python\n  import functools\n\n  def log(text):\n      def decorator(func):\n          @functools.wraps(func)\n          def wrapper(*args, **kw):\n              print(\'%s %s():\' % (text, func.__name__))\n              return func(*args, **kw)\n          return wrapper\n      return decorator\n  ```\n\n## 偏函数\n\n- 为一个函数设置默认传入参数。\n\n- ```python\n  int2 = functools.partial(int, base=2)\n  #相当于\n  def int2(x, base = 2):\n      return int(x, base)\n  # 将二进制转为十进制\n  print(int2(\'1001\'))\n  ```\n\n- 使用`functools.partial`可以固定住原函数的部分参数，从而在调用时更简单。\n\n## 模块\n\n- ```python\n  if __name__==\'__main__\':\t\t# 判断是否直接运行\n      start()\n  ```\n\n- `__x__`这样的变量时特殊变量，可以被引用。\n\n- `__x`这样的变量时非公开的，不应直接引用。\n'}}]);