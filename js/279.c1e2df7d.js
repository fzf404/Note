(window.webpackJsonp=window.webpackJsonp||[]).push([[279],{907:function(n,e){n.exports="\x3c!--\ntitle: 05-Python面向对象\nsort:\n--\x3e\n\n# Python 面向对象\n\n- 面向对象的设计思想是抽象出 Class（类），根据 Class 创建 Instance（实例）。\n\n- python 中所有数据类型可成为对象，可自行创建 Class。\n\n  > classs 是人，instance 是他人 ，你会有些属性：身高、年龄、体重，你会有些技能：吃饭、写代码。\n  >\n  > `__init__` 方法，就是上帝初始化你的属性。比如`zhangsan = Person(170,29,50)`这时上帝就实例化了你。\n  >\n  > 你到底有哪些技能呢，如果类里定义吃饭的技能，那么你就可以调用吃饭的技能来吃饭，看看下面的例子就更清楚了：\n  >\n  > ```python\n  > class Person(object):\n  > # 这里就是初始化你将要创建的实例的属性\n  > def __init__(self,hight,weight,age):\n  >   \tself.hight = hight\n  >   \tself.weight = weight\n  >   \tself.age = age\n  >\n  > # 定义你将要创建的实例所有用的技能\n  > def program(self):\n  >   \tprint('你开始编程了')\n  >\n  > def eat(self):\n  >   \tprint('you can eat')\n  >\n  > # 开始创建实例\n  > zhangsan=Person(170,50,29)      # 调用init\n  > lisi = Person(175,100,30)\n  >\n  > # 你的实例开始使用它的技能\n  > zhangsan.paoniu()\n  > lisi.eat()\n  > ```\n  >\n  > 另一个实例：\n  >\n  > ```python\n  > class 人类列表(object):\n  > def __init__(属性,姓名,性别,生日):\n  >   属性.姓名=姓名\n  >   属性.性别=性别\n  >   属性.生日=生日\n  >\n  > def 介绍(属性):\n  >   print(\"姓名:%s\"%属性.姓名)\n  >   print(\"性别:%s\" % 属性.性别)\n  >   print(\"生日:%s\"%属性.生日)\n  >\n  > one = 人类列表('dad','女',2001)\n  > two = 人类列表('fa','男',2001)\n  >\n  > one.介绍()\n  > two.介绍()\n  > ```\n\n## 类和实例\n\n- `Class`是抽象的模板，`Instance`是根据类创建出的对象，每个对象数据可能不同，但具有相同的方法。\n\n- 类名通常大写开头字母，`(object)`表示该类从哪个类继承。\n\n- 定义好一个类，就可以创建一个实例:`fzf = human()`。\n\n- `fzf`是指向`human`的实例。\n\n- 可以给变量绑定属性：`fzf.name = '你们的小f'`\n\n- 可以在创建类时绑定强制属性：\n\n  ```python\n  class Human(object):\n  \tdef __init__(self, name, sex):\t\t#此行强制要要求了两个属性\n  \t\tself.name = name\n  \t\tself.sex = sex\n  ```\n\n- `self`表示实例本身（当前还未创建的实例）。\n\n- 可以通过函数访问这些对象的数据。\n\n## 访问限制\n\n- 为了是内部属性不被外部访问，可在属性前加两个`_`。\n\n- `__xxx__`属于特殊变量，不是 private。\n\n- 例子：\n\n  ```python\n  class Student(object):\n      def __init__(self, name, gender):\n          self.name = name\n          self.__gender = gender\n      def get_gender(self):\n          return self.__gender\n      def set_gender(self, gender):\n          self.__gender = gender\n  ```\n\n## 继承和多态\n\n- 定义一个 class 时，可以使用现有的 class 继承，称为子类，被继承的叫做父类。\n\n- 子类可以使用父类的全部方法。\n\n- 当子类父类存在相同的方法时，子类的方法覆盖父类的。\n\n- 定义一个 class，相当于定义了一种数据类型（与 list、str、dict 没啥差别）\n\n- 判断变量类型可使用`isinstance()`判断。\n\n- 在继承关系中，一个实例的数据类型是某个子类，那它的数据类型也包括父类。\n\n- 这就是多态，可以传入任何父类类型。\n\n- 所有类都继承自 object。\n\n  ```python\n  class World(object):\n      def __init__(self, earth, country):\n          self.earth = earth\n          self.country = country\n\n      def timerun(self):\n          print(\"%sに%sのtime -1s \" % (self.earth, self.country))\n\n\n  class Human(World):\n      def humrun(self):\n          print('%s' % (self.speak))\n\n  h = Human('earth', 'china')\n  h.timerun()\n  h.speak = '233333'\t# 设定speak的值\n  h.humrun()\n\n  ```\n\n## 获取对象信息\n\n- `type`函数，判断对象类型。\n\n- 判断对象是否为函数，可使用 types 模块\n\n  ```python\n  >>> import types\n  >>> def fn():\n  ...     pass\n  ...\n  >>> type(fn)==types.FunctionType\n  True\n  >>> type(abs)==types.BuiltinFunctionType\n  True\n  >>> type(lambda x: x)==types.LambdaType\n  True\n  >>> type((x for x in range(10)))==types.GeneratorType\n  True\n  ```\n\n- 优先使用`isinstance`判断继承关系。\n\n- `dir()`函数，获取对象的所有属性和方法。\n\n  > 8i `调用一个函数，相当于调用该对象的方法\n  >\n  > `len('abc') = 'abc'.__len__`\n\n- 配合`getattr()、setattr()、hasattr()`,操作一个对象的状态。\n\n  ```python\n  class MyObject(object):\n      def __init__(self):\n          self.x = 6\n      def power(self):\n          return self.x * self.x\n\n  obj = MyObject()\n  obj.x = 9\n  hasattr(obj, 'y')\t\t\t# 判断是否有y属性\n  setattr(obj, 'y', 10)\t\t# 新建y属性为10\n  print(getattr(obj, 'y'))\t# 打印y属性\n\n  fn = getattr(obj, 'power')\t# 获取fn函数的方法\n  print(fn())\t\t\t\t\t# 打印值\n  ```\n\n## 实例属性与类属性\n\n- 给实例绑定属性的方法：\n\n  > 在`__init__`中定义。\n  >\n  > 在调用过程中绑定。\n\n- 每次创建新实例并建立对象都会执行`__init__`函数\n\n- 可以给实例绑定方法：\n\n```python\ndef set_age(self, age):\n\tself.age = age\n\nfrom types import MethodType\nobj.set_age = MethdType(set_age, obj)\nobj.set_age(17)\nprint(obj.age)\n\nobj2.set_age(19)\t\t\t\t# 错误\n```\n\n- 可直接给 class 绑定方法：\n\n  `MyObject.set_age = set_age`\n\n- 在动态语言中是很容易的\n\n## 面向对象高级\n\n### 使用\\_\\_slots\\_\\_\n\n- 限制实例的属性，使其只能添加该属性。\n\n  ```python\n  class Student(object):\n      __slots__ = ('name', 'age')\t# 使用tuple定义属性\n  ```\n\n- 使用方法检查函数：\n\n  ```python\n  class Student(object):\n\n      def get_score(self):\n          return self._score\n\n      def set_score(self, value):\n          if not isinstance(value, int):\n              raise ValueError('score must be an integer!')\n          if value < 0 or value > 100:\n              raise ValueError('score must between 0 ~ 100!')\n          self._score = value\n\n\n  lisi = Student()\n  lisi.set_score(77)\n  print(lisi.get_score())\n  ```\n\n### 使用@property\n\n- 使用@property 装饰器来创建只读属性。\n\n- @property 装饰器会将**方法**转换为相同名称的只读属性\n\n  ```python\n  class DataSet(object):\n    @property\n    def method_with_property(self): # 含有@property\n        return 15\n    def method_without_property(self): # 不含@property\n        return 15\n\n  l = DataSet()\n  print(l.method_with_property) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。\n  print(l.method_without_property())  #没有加@property , 必须使用正常的调用方法的形式，即在后面加()\n  两个都输出为15。\n  ```\n\n- 添加@property 后，方法变成了属性。\n\n  ```python\n  class DataSet(object):\n      def __init__(self):\n          self._images = 1\n          self._labels = 2 #定义属性的名称\n      @property\n      def images(self): #方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。\n          return self._images\n      @property\n      def labels(self):\n          return self._labels\n  l = DataSet()\n  #用户进行属性调用的时候，直接调用images即可，而不用知道属性名_images，因此用户无法更改属性，从而保护了类的属性。\n  print(l.images) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。\n  ```\n\n- 创建另外的装饰器，以便于赋值：\n\n  ```python\n  class Student(object):\n\n      @property\n      def score(self):\n          return self.a_attr\n\n      @score.setter\n      def score(self, value):\n          if not isinstance(value, int):\n              raise ValueError('score must be an integer!')\n          if value < 0 or value > 100:\n              raise ValueError('score must between 0 ~ 100!')\n          self.a_attr = value\n  ```\n\n- **小栗子**\n\n  ```python\n  class Human(object):\n      def __init__(self, country, name):\n          self.country = country\n          self.name = name\n          self._chairman = '川建国'\n\n      @property\n      def chairman(self):\n          return self._chairman\n\n      @chairman.setter\n      def chairman(self, value):\n          self._chairman = value\n\n\n  f = Human('china', 'fzf')\n  # f.chairman = '习近平'\n  print(f.chairman)\n\n  ```\n\n### 多重继承\n\n- 当对象分类较多时，可使用继承简化代码。\n\n  > 先创建大类，在其中建立功能\n  >\n  > 再创建小类，继承大类功能。\n\n- **MIxln**：给一个类增加多个功能\n\n### 定制类\n\n- **\\_\\_str\\_\\_()**：实例返回值\n\n  ```python\n  class Student(object):\n       def __init__(self, name):\n           self.name = name\n       def __str__(self):\n           return 'Student object (name: %s)' % self.name\n\n  print(Student('Michael'))\n  > Student object (name: Michael)\n  # <__main__.Student object at 0x109afb310>\n  ```\n\n- **\\_\\_repr\\_\\_()**：定义变量返回值\n\n  ```python\n  class Student(object):\n      def __init__(self, name):\n          self.name = name\n      def __str__(self):\n          return 'Student object (name=%s)' % self.name\n      __repr__ = __str__\t\t\t\t# 偷懒写法\n\n  s = Student('Michael')\n  print(s)\n  ```\n\n- **\\_\\_iter\\_\\_**：返回迭代对象\n\n  > 使一个类可以被用于 for 循环。\n\n  ```python\n  class Fib(object):\n      def __init__(self):\n          self.a, self.b = 0, 1 \t\t# 初始化两个计数器a，b\n\n      def __iter__(self):\n          return self \t\t\t\t# 实例本身就是迭代对象，故返回自己\n\n      def __next__(self):\n          self.a, self.b = self.b, self.a + self.b # 计算下一个值\n          if self.a > 100000: # 退出循环的条件\n              raise StopIteration()\n          return self.a \t\t\t\t\t\t\t# 返回下一个值\n\n  for n in Fib():\n      print(n)\n  ```\n\n- **\\_\\_getitem\\_\\_**：比楼上牛逼\n\n  > 不返回一个`generator`对象。\n  >\n  > 返回一个可以使用下标读取文件。\n\n  ```python\n  class Fib(object):\n      def __getitem__(self, n):\n          a, b = 1, 1\n          for x in range(n):\n              a, b = b, a + b\n          return a\n  f = Fib()\n  f[5:10]\t\t\t\t# 报错\n  ```\n\n- 小栗子\n\n  ```python\n  class Fib(object):\n      def __getitem__(self, n):\n          if isinstance(n, int): # n是索引\n              a, b = 1, 1\n              for x in range(n):\n                  a, b = b, a + b\n              return a\n          if isinstance(n, slice): # n是切片\n              start = n.start\n              stop = n.stop\n              if start is None:\n                  start = 0\n              a, b = 1, 1\n              L = []\n              for x in range(stop):\n                  if x >= start:\n                      L.append(a)\n                  a, b = b, a + b\n             return L\n  ```\n\n- **\\_\\_getattr\\_\\_**：尝试获得属性\n\n  > 未找到属性时，会自动调用\\_\\_getattr\\_\\_\n\n  ```python\n  class Student(object):\n\n      def __init__(self):\n          self.name = 'Michael'\n\n      def __getattr__(self, attr):\n          if attr=='score':\n              return 99\n          raise AttributeError('\\'Student\\' object has no attribute \\'%s\\'' % attr)\n  ```\n\n- 小栗子：\n\n  ```python\n  class Vpow(object):\n\n      def __init__(self, x, y=2):\t\t\t\t# 初始化变量\n          self.x = x\n          self.y = y\n\n      def __iter__(self):\t\t\t\t\t\t# 定义迭代变量\n          return self\n\n      def __next__(self):\n          self.x = self.x ** self.y\n          if self.x > 4294967296:\n              raise StopIteration()\n          return self.x\n\n      def __str__(self):\t\t\t\t\t\t# 设置返回值\n          return 'Student object (x=%s, y=%s)' % (self.x, self.y)\n      __repr__ = __str__\n\n\n  v = Vpow(2)\n  x = Vpow(2,3)\n  print(v)\n  print(list(v),list(x))\n  ```\n\n- **\\_\\_call\\_\\_**：直接调用实例\n\n  > 可以直接对实例进行调用。\n\n  ```python\n  class Student(object):\n      def __init__(self, name):\n          self.name = name\n\n      def __call__(self):\n          print('My name is %s.' % self.name)\n\n  s = Student('Fzf')\n  s()\t\t\t\t\t\t\t\t# My name is Fzf.\n  ```\n\n  > 判断一个变量是否可以被调用：`callable(s)`\n\n### 使用枚举类\n\n- 运用`Enum`定义枚举常量：\n\n  ```python\n  from enum import Enum\n\n  Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))\t\t\t# 默认从1计数\n\n  for name, member in Month.__members__.items():\n      print(name, '=>', member, ',', member.value)\n  ```\n\n- 想要更精准的控制枚举类型可从`Enum`派生自定义类：\n\n  ```python\n  from enum import Enum, unique\n\n  @unique\t\t\t\t\t#判断是否有重复\n  class Weekday(Enum):\n      Sun = 0 \t\t\t# Sun的value被设定为0\n      Mon = 1\n      Tue = 2\n      Wed = 3\n      Thu = 4\n      Fri = 5\n      Sat = 6\n  ```\n\n- 访问的方法：\n\n  > 类名.常量名 -》本身\n  >\n  > 类名[常量名] -》同上\n  >\n  > 类名.常量名.value -》值\n  >\n  > 类名.\\_\\_members\\_\\_.item() -》可迭代类型\n  >\n  > - 特殊属性* `__members__` *是一个将名称映射到成员的有序字典，也可以通过它来完成遍历：\n\n  ```python\n    >>> day1 = Weekday.Mon\n    >>> print(day1)\t\t\t\t\t# 返回常量名\n    Weekday.Mon\n    >>> print(Weekday.Tue)\n    Weekday.Tue\n    >>> print(Weekday['Tue'])\n    Weekday.Tue\n    >>> print(Weekday.Tue.value)\t\t# 返回值\n    2\n    >>> print(day1 == Weekday.Mon)\n    True\n    >>> print(day1 == Weekday.Tue)\n    False\n    >>> print(Weekday(1))\n    Weekday.Mon\n    >>> print(day1 == Weekday(1))\n    True\n    >>> Weekday(7)\n    Traceback (most recent call last):\n      ...\n    ValueError: 7 is not a valid Weekday\n    >>> for name, member in Weekday.__members__.items():\n  ...     print(name, '=>', member)\n    ...\n    Sun => Weekday.Sun\n    Mon => Weekday.Mon\n    Tue => Weekday.Tue\n    Wed => Weekday.Wed\n    Thu => Weekday.Thu\n    Fri => Weekday.Fri\n    Sat => Weekday.Sat\n  ```\n\n### 使用元类\n\n- `type()`函数可以查看一个类型或变量的类型。\n\n  > class 的类型是`type`\n  >\n  > 实例的类型是`class '所有函数'`\n\n- `type()`函数既可以返回一个对象的类型，又可以创建出新的类型。\n\n  > 先定义函数，\n  >\n  > 再通过`type()`创建类：\n  >\n  > 1. class 的名称\n  > 2. 继承的父类集合（只有一个记得 tuple 的单元素写法）\n  > 3. 绑定方法对应的函数\n\n  ```python\n  def fn(self, name='world'): \t\t# 先定义函数\n  \tprint('Hello, %s.' % name)\n\n  Hello = type('Hello', (object,), dict(hello=fn))\n  ```\n\n- `metaclass`控制创建类的实例。\n\n  > 先定义类，然后创建实例。\n  >\n  > 如果我们想创建出类呢？那就必须根据 metaclass 创建出类。\n  >\n  > 先定义 metaclass，就可以创建类，最后创建实例。\n"}}]);