(window.webpackJsonp=window.webpackJsonp||[]).push([[317],{945:function(n,a){n.exports="\x3c!--\ntitle: A2-Pandas\nsort:\n--\x3e\n\n# Pandas\n\n## 基本\n\n- 初识 pandas\n\n  `import pandas as pd`\n\n  `pd.__version__`\n\n- 主要数据\n\n  > `DateFrame`：一个关系型数据表格，其中包含多个行和已命名的列。\n  >\n  > `series`：`DataFrame` 中包含一个或多个 `Series`，每个 `Series` 均有一个名称。\n\n## 使用方法\n\n> 构建 `Series` 对象.\n>\n> 创建`DateFrame`对象：\n>\n> ```python\n> 城市名称 = pd.Series(['San Francisco', 'San Jose', 'Sacramento'])\n> 人口 = pd.Series([852469, 1015785, 485199])\n>\n> pd.DataFrame({ 'City name': 城市名称, '人口': 人口 })\n> ```\n>\n> 加载文件：\n>\n> ```python\n> 数据表 = pd.read_csv(\"x.csv\", sep=\",\")\n> # 显示关于DataFrame的统计信息\n> 数据表.describe()\n> # 显示前几个记录\n> 数据表.head()\n> # 绘制图表\n> 数据表.hist('series_name')\n> ```\n>\n> 可以使用熟悉的 Python dict/list 指令访问 `DataFrame` 数据：\n>\n> ```python\n> 城市信息 = pd.DataFrame({ 'City name': 城市名称, '人口': 人口 })\n>\n> 城市信息['City name']\n> '''\n> <class 'pandas.core.series.Series'>\n> 0    San Francisco\n> 1         San Jose\n> 2       Sacramento\n> Name: City name, dtype: object\n> '''\n> print(type(城市信息['City name'][1]))\n> 城市信息['City name'][1]\n> '''\n> <class 'str'>\n> 'San Jose\n> '''\n> 城市信息[0:2]\n> '''\n> \tCity name\t人口\n> 0\tSan Francisco\t852469\n> 1\tSan Jose\t1015785\n> '''\n> # 别的方法\n> 城市信息.iloc[1,2]\t# 第一行第二个\n> .iloc[1,:][人口]\n> ```\n\n## 操作数据\n\n> ```python\n> 城市信息['Area square miles'] = pd.Series([46.87, 176.53, 97.92])\n>\n> 城市信息['人口'] = 城市信息['人口'] / 城市信息['Area square miles']\n>\n> # 选择最大值\n> idxmax()\n> ```\n\n`Series.apply` 以参数形式接受 [lambda 函数](https://docs.python.org/2/tutorial/controlflow.html#lambda-expressions)，而该函数会应用于每个值。\n\n```python\n人口.apply(lambda val: val > 1000000)\n\n0    False\n1     True\n2    False\ndtype: bool\n```\n\n## 索引\n\n> `Series` 和 `DataFrame` 对象也定义了 `index` 属性，该属性会向每个 `Series` 项或 `DataFrame` 行赋一个标识符值。\n>\n> 调用 `DataFrame.reindex` 以手动重新排列各行的顺序。\n>\n> `城市信息.reindex([2, 0, 1])`\n>\n> 重建索引是一种随机排列 `DataFrame` 的绝佳方式。\n>\n> `城市信息.reindex(np.random.permutation(城市信息.index))`\n"}}]);