(window.webpackJsonp=window.webpackJsonp||[]).push([[286],{914:function(n,e){n.exports="\x3c!--\ntitle: 10-异步编程\nsort:\n--\x3e\n\n# 异步 IO\n\n- 同步 IO 浪费 CPU 的时间\n\n  > ```python\n  > do_some_code()\n  > f = open('/path/to/file', 'r')\n  > r = f.read() # <== 线程停在此处等待IO操作结果\n  > # IO操作完成后线程才能继续执行:\n  > do_some_code(r)\n  > ```\n  >\n  > 假如一个程序需要读取键盘输入，使用同步 IO 极大浪费 cpu 资源\n\n- 异步 IO，主线程不断重复‘读取消息-处理消息’这一过程\n\n  > ```python\n  > loop = get_event_loop()\n  > while True:\n  >     event = loop.get_event()\n  >     process_event(event)\n  > ```\n\n## 协程\n\n```python\nimport time\n\n\ndef n1():\n    while True:\n        print(\"n1 start.\")\n        yield\n        print(\"n1 sleep start.\")\n        time.sleep(1)\n        print(\"n1 sleep over\")\n\n\ndef n2():\n    while True:\n        print(\"n2 start.\")\n        yield\n        print(\"n2 sleep start.\")\n        time.sleep(0.5)\n        print(\"n2 sleep over\")\n\n\nn1 = n1()\nn2 = n2()\nwhile True:\n    next(n1)\n    next(n2)\n```\n\n> 子程序调用总是一个入口，一次返回，调用顺序明确。\n>\n> 而协程的调用和子程序不同。\n>\n> 执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。\n>\n> 例子：\n>\n> ```python\n> def A():\n>     print('1')\n>     print('2')\n>     print('3')\n>\n> def B():\n>     print('x')\n>     print('y')\n>     print('z')\n> '''\n> 由协程执行\n> 1\n> 2\n> x\n> y\n> 3\n> z\n> '''\n> ```\n>\n> 看似多进程，但却是一个进程。\n>\n> Python 对协程的支持是通过 generator 实现的。\n>\n> 传统是一个线程写消息，一个线程取消息，但一不小心就可能死锁。\n>\n> 改用协程，生产消息后，直接通过`yield`跳转到执行，待执行完毕后，切换继续生产，效率极高\n\n- 例子\n\n  ```python\n  def consumer():\n      r = ''\n      while True:\n          # 接收send的值, 并将r返回至 produce,\n          n = yield r\n          # 下次send从这里开始执行\n          if not n:\n              return\n          print('[CONSUMER] Consuming %s...' % n)\n          r = '200 OK'\n\n  c = consumer()\n\n  def produce(c):\n      # 作用类似于next(c),r为空，n为None。\n      c.send(None)    # 启动生成器, yield r 为空\n      n = 0\n      while n < 5:\n          n = n + 1\n          print('[PRODUCER] Producing %s...' % n)\n          # 传入值n=1，n被赋值为1\n          # 进入第二次循环 yield r,将 r yield至 consumer。\n          r = c.send(n)\n          print('[PRODUCER] Consumer return: %s' % r)\n      c.close()\n\n\n  c = consumer()\n  produce(c)\n\n  ```\n\n- 运行结果\n\n  ```python\n  [PRODUCER] Producing 1...\n  [CONSUMER] Consuming 1...\n  [PRODUCER] Consumer return: 200 OK\n  [PRODUCER] Producing 2...\n  [CONSUMER] Consuming 2...\n  [PRODUCER] Consumer return: 200 OK\n  [PRODUCER] Producing 3...\n  [CONSUMER] Consuming 3...\n  [PRODUCER] Consumer return: 200 OK\n  [PRODUCER] Producing 4...\n  [CONSUMER] Consuming 4...\n  [PRODUCER] Consumer return: 200 OK\n  [PRODUCER] Producing 5...\n  [CONSUMER] Consuming 5...\n  [PRODUCER] Consumer return: 200 OK\n  ```\n\n## asyncio\n\n> `asyncio`是 python 标准库，内置异步 IO 的支持。\n>\n> 即一个消息循环，从模块中直接获取一个`EventLoop`的引用，\n>\n> 然后把协程扔到`EventLoop`中执行。\n\n- `yield from`\n\n  ```python\n  # 等价于\n  titles = ['Python','Java','C++']\n  for title in titles:　# 等价于yield from titles\n      yield title　\n  ```\n\n- Hello Async\n\n  ```python\n  import asyncio\n\n  @asyncio.coroutine\n  def hello():\n      print(\"Hello async!\")\n      # 异步调用asyncio.sleep(1):\n      r = yield from asyncio.sleep(1)\n      # yield语法用于调用另一个generator\n      print(\"Hello again!\")\n\n  # 获取EventLoop:\n  loop = asyncio.get_event_loop()\n  # 执行coroutine\n  loop.run_until_complete(hello())\n  loop.close()\n  ```\n\n- `yield from`\n\n  > yield from titles\n  >\n  > 相当于 for title in titles\n\n- 例子\n\n  ```python\n  def generator_1():\n      total = 0\n      while True:\n          x = yield\n          print('加',x)\n          if not x:\n              break\n          total += x\n      return total\n  def generator_2(): # 委托生成器\n      while True:\n          total = yield from generator_1() # 子生成器\n          print('加和总数是:',total)\n  def main(): # 调用方\n      g1 = generator_1()\n      g1.send(None)\n      g1.send(2)\n      g1.send(3)\n      g1.send(None)\n      # g2 = generator_2()\n      # g2.send(None)\n      # g2.send(2)\n      # g2.send(3)\n      # g2.send(None)\n\n  main()\n  ```\n\n  > 【子生成器】：yield from 后的 generator_1()生成器函数是**子生成器**\n  > 【委托生成器】：generator_2()是程序中的**委托生成器**，它负责委托**子生成器**完成具体任务。\n  > 【调用方】：main()是程序中的**调用方**，负责调用委托生成器。\n\n- 显示当前线程\n\n  ```python\n  import threading\n  import asyncio\n\n  @asyncio.coroutine\n  def hello():\n      print('Hello world! (%s)' % threading.currentThread())\n      yield from asyncio.sleep(1)\n      print('Hello again! (%s)' % threading.currentThread())\n\n  loop = asyncio.get_event_loop()\n  tasks = [hello(), hello()]\n  loop.run_until_complete(asyncio.wait(tasks))\n  loop.close()\n  '''\n  Hello world! (<_MainThread(MainThread, started 13716)>)\n  Hello world! (<_MainThread(MainThread, started 13716)>)\n  Hello again! (<_MainThread(MainThread, started 13716)>)\n  Hello again! (<_MainThread(MainThread, started 13716)>)\n  '''\n  ```\n\n- 例子\n\n  ```python\n  # 使用同步方式编写异步功能\n  import time\n  import asyncio\n  @asyncio.coroutine # 标志协程的装饰器\n  def taskIO_1():\n      print('开始运行IO任务1...')\n      yield from asyncio.sleep(2)  # 假设该任务耗时2s\n      print('IO任务1已完成，耗时2s')\n      return taskIO_1.__name__\n  @asyncio.coroutine # 标志协程的装饰器\n  def taskIO_2():\n      print('开始运行IO任务2...')\n      yield from asyncio.sleep(3)  # 假设该任务耗时3s\n      print('IO任务2已完成，耗时3s')\n      return taskIO_2.__name__\n  @asyncio.coroutine # 标志协程的装饰器\n  def main(): # 调用方\n      tasks = [taskIO_1(), taskIO_2()]  # 把所有任务添加到task中\n      done,pending = yield from asyncio.wait(tasks) # 子生成器\n      for r in done: # done和pending都是一个任务，所以返回结果需要逐个调用result()\n          print('协程无序返回值：'+r.result())\n\n  if __name__ == '__main__':\n      start = time.time()\n      loop = asyncio.get_event_loop() # 创建一个事件循环对象loop\n      try:\n          loop.run_until_complete(main()) # 完成事件循环，直到最后一个任务结束\n      finally:\n          loop.close() # 结束事件循环\n      print('所有IO任务总耗时%.5f秒' % float(time.time()-start))\n  ```\n\n  > done 表示已完成的任务列表，pending 表示未完成的任务列表。\n  >\n  > **遇到**该**任务中的`yield from`中断**，开始**处理下一个事件**\n  >\n  > 当`yield from`后面的子生成器**完成任务**时，该事件才再次**被唤醒**\n\n- 使用`async`\n\n  ```python\n  import time\n  import asyncio\n  async def taskIO_1():\n      print('开始运行IO任务1...')\n      await asyncio.sleep(2)  # 假设该任务耗时2s\n      print('IO任务1已完成，耗时2s')\n      return taskIO_1.__name__\n  async def taskIO_2():\n      print('开始运行IO任务2...')\n      await asyncio.sleep(3)  # 假设该任务耗时3s\n      print('IO任务2已完成，耗时3s')\n      return taskIO_2.__name__\n  async def main(): # 调用方\n      tasks = [taskIO_1(), taskIO_2()]  # 把所有任务添加到task中\n      done,pending = await asyncio.wait(tasks) # 子生成器\n      for r in done: # done和pending都是一个任务，所以返回结果需要逐个调用result()\n          print('协程无序返回值：'+r.result())\n\n  if __name__ == '__main__':\n      start = time.time()\n      loop = asyncio.get_event_loop() # 创建一个事件循环对象loop\n      try:\n          loop.run_until_complete(main()) # 完成事件循环，直到最后一个任务结束\n      finally:\n          loop.close() # 结束事件循环\n      print('所有IO任务总耗时%.5f秒' % float(time.time()-start))\n\n  ```\n\n### 使用异步连接网络\n\n```python\nimport asyncio\n\n@asyncio.coroutine\ndef wget(host):\n    print('wget %s...' % host)\n    connect = asyncio.open_connection(host, 80)\n    reader, writer = yield from connect\n    header = 'GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % host\n    writer.write(header.encode('utf-8'))\n    yield from writer.drain()\n    while True:\n        line = yield from reader.readline()\n        if line == b'\\r\\n':\n            break\n        print('%s header > %s' % (host, line.decode('utf-8').rstrip()))\n    # Ignore the body, close the socket\n    writer.close()\n\nloop = asyncio.get_event_loop()\ntasks = [wget(host) for host in ['www.sina.com.cn', 'www.sohu.com', 'www.163.com']]\nloop.run_until_complete(asyncio.wait(tasks))\nloop.close()\n```\n\n## async/await\n\n> Python 3.5 后引入了新的`async`与`await`\n\n```python\nasync def hello():\n    print(\"Hello world!\")\n    r = await asyncio.sleep(1)\n    print(\"Hello again!\")\n```\n\n## greenlet\n\n```python\nfrom greenlet import greenlet\n\nfunc1():\n    print(\"1 start\")\n    g2.switch()\n\nfunc2():\n    print(\"2 start\")\n    g1.switch()\n\ng1 = greenlet(func1)\ng2 = greenlet(func2)\ng1.switch()\n```\n"}}]);