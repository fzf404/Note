(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{812:function(n,r){n.exports="\x3c!--\ntitle: Arm汇编\nsort:\n--\x3e\n\n## 环境\n\n> 树莓派\n>\n> [gef](https://github.com/hugsy/gef)\n\n## HelloWorld\n\n```assembly\n# demo.s\n.data          /*.data段是动态创建的，无法预测 */\nvar1: .word 3  /* 内存中的变量var1=3*/\nvar2: .word 4  /* 内存中的变量var2=4*/\n\n.text          /* 代码段开始位置 */\n.global _start\n\n_start:\n    ldr r0, adr_var1  @ 通过标签adr_var1获得变量var1的地址，并加载到R0。\n    ldr r1, adr_var2  @ 通过标签adr_var2获得变量var2的地址，并加载到R1。\n    ldr r2, [r0]      @ 通过R0内的地址获取到该地址处的值（0x03)，加载到R2。\n    str r2, [r1]      @ 将R2内的值（0x03）存储到R1中的地址处。\n    bkpt\n\nadr_var1: .word var1  /* 变量var1的地址位置 */\nadr_var2: .word var2  /* 变量var2的地址位置 */\n\n# 编译运行\nas demo.s -o demo.o\nld demo.o -o demo\n# gef调试\ngdb -f demo\n# 打断点\ngef> br _start\ngef> run\t\t\t# 运行\ngef> nexti \t\t# 运行下一条命令\ngef> info register r0\tr2\t# 查看寄存器的值\nr0 = 0x20090 \t\t\t\t\t# r0的值是var1的地址\ngef> x/w 0x20090\t\t\t# 查看内存的值\ngef> x/4w 0x20090\t\t\t# 查看4个内存的值\n```\n\n## 数据类型\n\n![img](https://img-1257284600.cos.ap-beijing.myqcloud.com/2021/data-types-1.png)\n\n```assembly\nldr = Load Word\nldrh = Load unsigned Half Word\nldrsh = Load signed Half Word\nldrb = Load unsigned Byte\nldrsb = Load signed Bytes\n\nstr = Store Word\nstrh = Store unsigned Half Word\nstrsh = Store signed Half Word\nstrb = Store unsigned Byte\nstrsb = Store signed Byte\n```\n\n## 寄存器\n\n|   ARM    |                 Description                 |           x86           |\n| :------: | :-----------------------------------------: | :---------------------: |\n|    R0    |               General Purpose               |           EAX           |\n|  R1-R5   |               General Purpose               | EBX, ECX, EDX, ESI, EDI |\n|  R6-R10  |               General Purpose               |            –            |\n| R11 (FP) |                Frame Pointer                |           EBP           |\n|   R12    |            Intra Procedural Call            |            –            |\n| R13 (SP) |                Stack Pointer                |           ESP           |\n| R14 (LR) |              记录父函数的地址               |            –            |\n| R15 (PC) | <- Program Counter / Instruction Pointer -> |           EIP           |\n|   CPSR   |    Current Program State Register/Flags     |         EFLAGS          |\n\n### 状态寄存器\n\n| thumb        | fast     | interrupt | overflow | carry    | zero     | negative |\n| ------------ | -------- | --------- | -------- | -------- | -------- | -------- |\n| 工作状态标志 | 用户模式 | 中断标志  | 溢出标志 | 进位标志 | 零标志位 | 符号标志 |\n\n## 指令集\n\n### ARM 和 Thumb 模式\n\n> ARM 模式下指令集始终是 32-bit\n>\n> Thumb 模式下可以是 16-bit 或者 32-bit\n\n### 指令\n\n> 指令的格式\n\n```assembly\nMNEMONIC{S}{condition} {Rd}, Operand1, Operand2\nMNEMONIC     - 操作指令（机器码对应的助记符）。\n{S}          - 可选后缀. 如果指定了该后缀，那么条件标志将根据操作结果进行更新。\n{condition}  - 执行指令所需满足的条件。\n{Rd}         - 目标寄存器，存储操作结果。\nOperand1     - 第一操作数（寄存器或者立即数）\nOperand2     - 第二操作数. 立即数或者带有位移操作后缀（可选）的寄存器。\n  #123                    - 立即数。\n  Rx                      - 寄存器x (如 R1, R2, R3 ...)。\n  Rx, ASR n               - 寄存器x，算术右移n位 (1 = n = 32)。\n  Rx, LSL n               - 寄存器x，逻辑左移n位 (0 = n = 31)。\n  Rx, LSR n               - 寄存器x，逻辑右移n位 (1 = n = 32)。\n  Rx, ROR n               - 寄存器x，循环右移n位 (1 = n = 31)。\n  Rx, RRX                 - 寄存器x，扩展的循环位移，右移1位。\n\nADD   R0, R1,          \t - R0与R1的值相加，存储到R0。\nADD   R0, R1, R2         - R1与R2的值相加，存储到R0。\nADD   R0, R1, #2         - R1内的值加2，存储到R0。\nMOVLE R0, #5             - 仅当满足条件LE（R0<=5）时，将立即数5移动到R0（编译器会把它看作MOVLE R0, R0, #5）。\nMOV   R0, R1, LSL #1     - 将寄存器R1的内容向左移动一位然后移动到R0（Rd）。因此，如果R1值是2，它将向左移动一位，并变为4。然后将4移动到R0。\n```\n\n### 指令表\n\n| Instruction | Description            | Instruction | Description                   |\n| :---------: | :--------------------- | :---------: | :---------------------------- |\n|     MOV     | 移动数据               |     EOR     | Bitwise XOR                   |\n|     MVN     | Move and negate        |     LDR     | 内存加载到寄存器              |\n|             |                        |     ADR     | 内存地址加载到服务器          |\n|     ADD     | Addition               |     STR     | 寄存器存到内存                |\n|     SUB     | Subtraction            |     LDM     | 批量加载                      |\n|     MUL     | Multiplication         |     STM     | 批量保存                      |\n|     LSL     | Logical Shift Left     |    PUSH     | Push on Stack                 |\n|     LSR     | Logical Shift Right    |     POP     | Pop off Stack                 |\n|     ASR     | Arithmetic Shift Right |      B      | Branch                        |\n|     ROR     | Rotate Right           |     BL      | Branch with Link              |\n|     CMP     | Compare                |     BX      | Branch and eXchange           |\n|     AND     | Bitwise AND            |     BLX     | Branch with Link and eXchange |\n|     ORR     | Bitwise OR             |   SWI/SVC   | System Call                   |\n\n### 内存指令\n\n```assembly\n# R0内存地址的值存到R2\nLDR R2, [R0]   @ [R0] - R0中保存的值是源地址。\nLDR R2, [R0, #12]\t\t@ 相对寻址，R0+12的地址的值\n# R2的值存到R1内存地址\nSTR R2, [R1]   @ [R1] - R1中保存的值是目标地址\n\nstr r2, [r1, #2]  @ R2值存到R1+2地址中，R1值不变。\nstr r2, [r1, #4]! @ R2值存到R1+2地址中，R1值+4。\nldr r3, [r1], #4  @ R1地址的值加载到R3，R1值+4。\n\nstr r2, [r1, r2]  @ R1+R2偏移地址的值加载到R2，R1不变\nstr r2, [r1, r2]! @ 同上，R1变为R1+R2\nldr r3, [r1], r2  @ R1地址的值加载到R3，R1值+R2。\n\nstr r2, [r1, r2, LSL#2]  @ R1+R2左移两位地址的值加载到R2，R1不变\nstr r2, [r1, r2, LSL#2]! @ 同上上\nldr r3, [r1], r2, LSL#2  @ R1地址的值加载到R3，R1值+R2左移2位。\n```\n\n### 批量操作\n\n```assembly\nwords:\n .word 0x00000000             /* words[0] */\n .word 0x00000001             /* words[1] */\n .word 0x00000002             /* words[2] */\n .word 0x00000003             /* words[3] */\n .word 0x00000004             /* words[4] */\n .word 0x00000005             /* words[5] */\n .word 0x00000006             /* words[6] */\n\nadr r0, words+12\t@ 将word[3]的地址放到r0中\nldm r0, {r4,r5}  \t@ 批量加载r0地址的值到r4,r5\n@ 正向加载\nldmia r0, {r4-r6}\t@ 将words[3]-[5]的值批量保存到r4-r6\nldmib r0, {r4-r6}\t@ 将words[4]-[6]的值批量保存到r4-r6\n@ 反向加载\nldmda r0, {r4-r6}\t@ 将words[3]-[1]的值批量保存到r4-r6\nldmda r0, {r4-r6}\t@ 将words[3]-[1]的值批量保存到r4-r6\n```\n\n### 立即数\n\n> arm32 位指令\n>\n> 分配到立即数只有 12 位(4096 位\n\n1. 使用较小的值构造较大值`MOV r0, #256 `和`ADD r0, #255`\n\n2. 编译器处理: `LDR r1, = 511`\n\n### 栈\n\n```assembly\npush {r0, r1}\npop {r2, r3}\n\nstmdb sp!, {r0, r1}\nldmia sp!, {r4, r5}\n# 编译后也是堆栈操作\npush {r0, r1}\npop {r4, r5}\n```\n"}}]);