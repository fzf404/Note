(window.webpackJsonp=window.webpackJsonp||[]).push([[327],{955:function(n,F){n.exports="\x3c!--\ntitle: 03-汇编进阶\nsort:\n--\x3e\n\n# 汇编进阶\n\n## 进阶指令\n\n#### LEA\n\n> 指令获取内存编号\n>\n> `MOV eax, dword ptr ds:[esp+8]`\n>\n> esp 中的地址是允许访问的\n\n#### ADC\n\n> 带进位加法\n>\n> 假如 CF 为 1，则进位。\n\n#### SBB\n\n> 带进位减法\n\n#### XCHG\n\n> 交换寄存器的值\n\n#### MOVS\n\n> 移动内存间的数据 SI→DI\n>\n> ESI 与 EDI 自动增加\n\n```assembly\nMOVS BYTE PTR ES:[EDI], BYTE PTR DS:[ESI]\n; 简写为MOVSB MOVSW MOVSD\n```\n\n#### MOV\n\n> MOVSX 符号扩展 传送\n>\n> MOVZX 只 0 扩展\n>\n> ```assembly\n> MOV AL, 0xFF\t; 0x000000FF\n> MOVSX CX, AL\t; 0x0000FFFF\n>\n> MOV AL, 0xFF\t; 0x000000FF\n> MOVZX CX, AL\t; 0x000000FF\n> ```\n\n#### STOS\n\n> 将 AL/AX/EAX 的值存储到 EDI\n>\n> ESI 的值不变，EDI 变化\n\n```assembly\nSTOS BYTE PTR ES:[EDI]\n; 简写为STOSB W D\n```\n\n#### REP\n\n> 根据 ecx 的值，重复执行字符串命令\n\n#### JMP 地址\n\n> 修改 EIP 的值\n\n| 指令    | 用途                             |\n| ------- | -------------------------------- |\n| JE/JZ   | 相等跳转（equal/zero）           |\n| JNE     | 不相等时跳转（not equal）        |\n| JS/JNS  | 结果为负则跳转                   |\n| JP/JPE  | 偶数个数 PF=1                    |\n| JNP/JPO | PF=0                             |\n| JO/JNO  | OF=1/0                           |\n| JB/JNB  | 小于/不小于则跳转（Below）CF=1/0 |\n| JA/JNA  | 大于/不大于                      |\n| A/B     | 无符号大于小于                   |\n| G/L     | 有符号大于小于                   |\n\n#### CALL 地址\n\n> EIP 压入堆栈\n>\n> 并修改值\n\n#### RET\n\n> 回到 CALL\n\n#### CMP\n\n> 比较两个值\n>\n> 相当于 sub 两个值，并修改标志寄存器\n\n#### TEST\n\n> 比较两个值\n>\n> 相当于 and 两个值，并修改标志寄存器\n>\n> `TEST eax, eax`：判断 eax 是否为 0\n\n## 堆栈\n\n- 实现一个堆栈\n\n  > `top`是不断向小地址移动的。\n  >\n  > `base`的地址：最先压进数据的高位地址+1\n\n  ```assembly\n  MOV ebx,0x00002c00\t\t; 设置堆栈底\n  MOV edx,0x00002c00\t\t; 设置栈顶\n  MOV dword ptr ds:[edx-4], FFFFFFFF\t; 写入数据\n  SUB edx,4\t\t\t\t; 移动栈顶\n  ```\n\n- 读取堆栈\n\n  ```assembly\n  MOV eax,dword ptr ds:[edx]\n  LEA edx,dword ptr ds:[edx+4]\n  ```\n\n- 堆栈寄存器\n\n  > ESP 栈顶(stack top)\n  >\n  > EBP 栈底(bottom)\n\n- **使用系统的堆栈**\n\n  > `push 12345678`\n  >\n  > 系统会自动存入，并改变 esp 指向\n  >\n  > `pop eax`\n  >\n  > 取出值\n\n### 使用堆栈\n\n- 保存与恢复现场\n\n  > `pushad`\n  >\n  > `popad`\n  >\n  > 将所有寄存器的值压入堆栈\n  >\n  > ↑ 弹出堆栈\n\n## 标志寄存器\n\n1. CF 进位标志 (Carry Flag)\n\n   > 进位或借位都置 1\n\n   ```assembly\n   MOV eax, 5555FFFF\n   ADD ax, 1\n   ```\n\n2. PF 奇偶标志 (Parity Flag)\n\n   > 包含 1 的个数，偶数为 1，奇数为 0\n   >\n   > 只检查一个 byte 的 1 的个数\n\n3. AF 辅助进位 (Auxiliary)\n\n4. ZF 零标志位 (Zero)\n\n5. SF 符号标志 (Sign)\n\n   > 二进制最高位的值\n\n6. DF 方向标志 (direction)\n\n   > 1 减少\n   >\n   > 0 增加\n\n7. OF 溢出标志 (Over)\n\n   > 符号位进位 XOR 最高有效数值向符号位的进位 = OF\n\n8. DF\n\n   > 0 则 DI 为加\n\n## 其他寄存器\n\n### EIP\n\n> 指令计数器\n"}}]);