(window.webpackJsonp=window.webpackJsonp||[]).push([[281],{909:function(n,t){n.exports="\x3c!--\ntitle: 06-Python调试\nsort:\n--\x3e\n\n# Python 调试\n\n## 错误处理\n\n- 发生错误时返回错误代码。\n\n- 使用`try...except...finally...`处理错误：\n\n  > Python 的错误其实也是 class，所有的错误类型都继承自`BaseException`\n\n  ```python\n  try:\n      print('try...')\n      r = 10 / 0\n      print('result:', r)\n  except ZeroDivisionError as e:\t\t# 发生错误执行\n      print('except:', e)\t\t\t\t# ‘0’错误\n  except ValueError as e:\t\t\t\t# 值错误\n      print('ValueError:', e)\n  else:\t\t\t\t\t\t\t\t# 无错误执行\n      print('no error!')\n  finally:\t\t4\t\t\t\t\t# 一定执行\n      print('finally...')\n  print('END')\n  ```\n\n- 调用函数链：\n\n  > ```python\n  > Traceback (most recent call last):\t\t# 错误信息\n  >   File \"err.py\", line 11, in <module>\t# 出错位置\n  >     main()\n  >   File \"err.py\", line 9, in main\t\t# 原因再第九行\n  >     bar('0')\n  >   File \"err.py\", line 6, in bar\t\t\t# 原因在第六行\n  >     return foo(s) * 2\n  >   File \"err.py\", line 3, in foo\t\t\t# 最终原因\n  >     return 10 / int(s)\n  > ZeroDivisionError: division by zero \t# 错误类型\n  > ```\n\n- **记录错误**\n\n  > 可以使用内置的`logging`模块记录错误信息。\n  >\n  > 打印完错误信息后会继续执行。\n\n  ```python\n  # err_logging.py\n\n  import logging\n\n  def foo(s):\n      return 10 / int(s)\n\n  def bar(s):\n      return foo(s) * 2\n\n  def main():\n      try:\n          bar('0')\n      except Exception as e:\n          logging.exception(e)\n\n  main()\n  print('END')\n\n  '''\n  ERROR:root:division by zero\n  Traceback (most recent call last):\n    File \"err_logging.py\", line 13, in main\n      bar('0')\n    File \"err_logging.py\", line 9, in bar\n      return foo(s) * 2\n    File \"err_logging.py\", line 6, in foo\n      return 10 / int(s)\n  ZeroDivisionError: division by zero\n  END\n  '''\n  ```\n\n- **抛出错误**\n\n  > 可以自定义错误 class，列出可能出现的错误\n  >\n  > `raise`自动抛出异常\n  >\n  > 使用`raise`抛出错误实例。\n\n  ```python\n  class FooError(ValueError):\n      pass\n\n  def foo(s):\n      n = int(s)\n      if n==0:\n          raise FooError('invalid value: %s' % s)\n      return 10 / n\n\n  foo('0')\n\n  '''\n  Traceback (most recent call last):\n    File \"err_throw.py\", line 11, in <module>\n      foo('0')\n    File \"err_throw.py\", line 8, in foo\n      raise FooError('invalid value: %s' % s)\n  __main__.FooError: invalid value: 0\n  '''\n  ```\n\n## 调试\n\n- 出现问题时可以用`print()`\n\n- #### **assert**\n\n  > 可以用`assert`(断言)来替代。\n  >\n  > `assert`会抛出`assertionError`异常。\n  >\n  > 启动程序时可使用`-0`参数关闭。\n\n  ```python\n  def foo(s):\n      n = int(s)\n      assert n != 0, 'n is zero!'\t\t\t# 表达式错误，抛出异常\n      return 10 / n\n\n  def main():\n      foo('0')\n\n  # python -0 err.py\n  ```\n\n- ### **logging**\n\n  > `logging`不会抛出错误，而且可以输出到文件。\n  >\n  > 允许指定记录信息的级别，有`debug`，`info`，`warning`，`error`等几个级别。\n  >\n  > 当我们指定`level=INFO`时，`logging.debug`就不起作用了。指定`level=WARNING`后，`debug`和`info`就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。\n\n  ```python\n  import logging\n  logging.basicConfig(level=logging.INFO)\n\n  s = '0'\n  n = int(s)\n  logging.info('n = %d' % n)\n  print(10 / n)\n  ```\n\n- ### **pdb**\n\n  > 让程序以单步方式运行。\n\n  ```python\n  $ python -m pdb err.py\t\t# 运行代码\n  (Pdb) l\t\t\t\t\t\t# 显示全部代码\n  (Pdb) n\t\t\t\t\t\t# 运行下一行\n  (Pdb) p name\t\t\t\t# 可以输入命令p 变量名来查看变量\n  (Pdb) q\t\t\t\t\t\t# 结束程序\n  ```\n\n- ### pdb.set_trace()\n\n  > 命令用法同上\n\n  ```python\n  import pdb\n\n  s = '0'\n  n = int(s)\n  pdb.set_trace() \t\t\t# 设置一个断点，运行到这里会自动暂停\n  print(10 / n)\n  ```\n\n## PySnooper\n\n- @pysnooper.snoop()\n\n## 单元测试\n\n- 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。\n\n  > 1. 输入正数，比如`1`、`1.2`、`0.99`，期待返回值与输入相同；\n  > 2. 输入负数，比如`-1`、`-1.2`、`-0.99`，期待返回值与输入相反；\n  > 3. 输入`0`，期待返回`0`；\n  > 4. 输入非数值类型，比如`None`、`[]`、`{}`，期待抛出`TypeError`。\n\n- 把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。\n\n  ```python\n  # mydict.py\n  class Dict(dict):\n\n      def __init__(self, **kw):\n          super().__init__(**kw)\n\n      def __getattr__(self, key):\n          try:\n              return self[key]\n          except KeyError:\n              raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key)\n\n      def __setattr__(self, key, value):\n          self[key] = value\n\n  >>> d = Dict(a=1, b=2)\n  >>> d['a']\n  1\n  >>> d.a\n  1\n  ```\n\n  > 编写单元测试时，我们需要编写一个测试类，从`unittest.TestCase`继承。\n  >\n  > 以`test`开头的方法就是测试方法，不以`test`开头的方法不被认为是测试方法，测试的时候不会被执行。\n  >\n  > 对每一类测试都需要编写一个`test_xxx()`方法。由于`unittest.TestCase`提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是`assertEqual()`：\n\n  ```python\n  # 用于测试Dict\n  import unittest\n\n  from mydict import Dict\n\n  class TestDict(unittest.TestCase):\t\t# 继承\n\n      def test_init(self):\n          d = Dict(a=1, b='test')\n          self.assertEqual(d.a, 1)\t\t# 判断测试是否成功\n          self.assertEqual(d.b, 'test')\n          self.assertTrue(isinstance(d, dict))\n\n      def test_key(self):\n          d = Dict()\n          d['key'] = 'value'\n          self.assertEqual(d.key, 'value')\n\n      def test_attr(self):\n          d = Dict()\n          d.key = 'value'\n          self.assertTrue('key' in d)\n          self.assertEqual(d['key'], 'value')\n\n      def test_keyerror(self):\n          d = Dict()\n          with self.assertRaises(KeyError):\t# 判断程序会抛出KeyError\n              value = d['empty']\n\n      def test_attrerror(self):\n          d = Dict()\n          with self.assertRaises(AttributeError):\n              value = d.empty\n  ```\n\n- ### setUp 与 tearDown\n\n  > 在测是开始及结束时执行命令\n\n### 文档测试\n\n- Python 内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。\n\n  ```python\n  # mydict2.py\n  class Dict(dict):\n      '''\n      Simple dict but also support access as x.y style.\n\n      >>> d1 = Dict()\n      >>> d1['x'] = 100\n      >>> d1.x\n      100\n      >>> d1.y = 200\n      >>> d1['y']\n      200\n      >>> d2 = Dict(a=1, b=2, c='3')\n      >>> d2.c\n      '3'\n      >>> d2['empty']\n      Traceback (most recent call last):\n          ...\n      KeyError: 'empty'\n      >>> d2.empty\n      Traceback (most recent call last):\n          ...\n      AttributeError: 'Dict' object has no attribute 'empty'\n      '''\n      def __init__(self, **kw):\n          super(Dict, self).__init__(**kw)\n\n      def __getattr__(self, key):\n          try:\n              return self[key]\n          except KeyError:\n              raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key)\n\n      def __setattr__(self, key, value):\n          self[key] = value\n\n  if __name__=='__main__':\n      import doctest\n      doctest.testmod()\n  ```\n"}}]);