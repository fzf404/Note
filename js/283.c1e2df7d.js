(window.webpackJsonp=window.webpackJsonp||[]).push([[283],{911:function(n,e){n.exports="\x3c!--\ntitle: 08-Python进程\nsort:\n--\x3e\n\n# Python 进程与线程\n\n> 一个任务就是一个进程。\n>\n> 进程中的子进程称为线程。\n\n## 多线程\n\n```python\nfrom threading import Thread\nimport requests\n\nurl = \"http://39.106.186.128/api/register\"\n\ndef xss(i):\n    for i in range(i, i+10000):\n      r = requests.post(url, data={'user_name': i, 'passwd': 'qwert12345'})\n      print(str(i) + r.text)\n\nt1 = Thread(target=xss, args=(10000,))\nt2 = Thread(target=xss, args=(20000,))\n\nt1.start()\nt2.start()\n\n\nt1.join()\nt2.join()\n```\n\n> 设置守护进程，主进程结束后停止子进程\n>\n> `t.setDaemon(True)`\n>\n> 传入参数\n>\n> `(target = func, args=(i, ))`\n\n### 自定义线程类\n\n```python\nclass TestThr(threading.Thread):\n    # 调用父类的init\n    def __init__(self):\n        super().__init__()\n    def run(self):\n        for i in range(5):\n            print(\"正在执行子线程的run方法...\", i)\n            time.sleep(0.5)\n\n# 创建实例对象\ntest = TestThr()\n# 启用线程\ntest.start()\n# 运行过程中不影响下面代码执行\nprint(\"I'm coming in.\")\n```\n\n### LOCK\n\n> 多进程变量互相独立，而多线程为共享。\n>\n> 任何一个变量都可以被修改。\n\n#### 使用\n\n```python\n# 创建锁，全局变量\nlock = threading.Lock()\n# 上锁\nlock.acquire()\n# 执行操作\n# 解锁\nlock.release()\n```\n\n#### 例子\n\n```python\nimport time\nimport threading\n\nbalance = 0\n\n\ndef change_b(n):\n    global balance\n    balance = balance + n\n    balance = balance - n\n\ndef run_thread(n):\n    for i in range(1000000):\n        change_b(n)\n\nt1 = threading.Thread(target=run_thread, args=(5,))\nt2 = threading.Thread(target=run_thread, args=(8,))\nt1.start()\nt2.start()\nt1.join()\nt2.join()\nprint(balance)\t\t# balance不等于0\n\n# 将t1.join()放在t2.start()前面.即可先执行t1\n```\n\n- 使用锁\n\n```python\nlock = threading.Lock()\ndef run_thread(n):\n    for i in range(10000000):\n        lock.acquire()\n        change_b(n) # 修改变量函数\n        lock.release()\n```\n\n## ThreadLocal\n\n用于进程间通信\n\n```python\nimport threading\n\n\nLocal_name = threading.local()\n\n\ndef process_staff():\n    name = Local_name.criminal\n    print('I am process %sand I konw the criminal\\'s name is %s.\\n' %\n          (threading.current_thread().name, name))\n\n\ndef process_thread(name):\n    Local_name.criminal = name\n    print('I am process %s. Do you konw the criminal\\'s name?\\n' %\n          threading.current_thread().name)\n    process_staff()\n\nt1 = threading.Thread(target=process_thread,args=(\"fzf\",),name=\"007-1\")     # 这里的name是进程名\nt2 = threading.Thread(target=process_thread,args=(\"nmdxf\",),name=\"007-2\")   # 这里的name是进程名\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n```\n\n> 全局变量`local_school`就是一个`ThreadLocal`对象，你可以把`local_school`看成全局变量，每个属性如`local_school.student`都是线程的局部变量，`ThreadLocal`内部会处理锁的问题。\n\n> 可以理解为全局变量`local_school`是一个`dict`，不但可以用`local_school.student`，还可以绑定其他变量，如`local_school.teacher`等等。\n\n> `ThreadLocal`最常用的地方就是为每个线程绑定一个数据库连接，HTTP 请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。\n\n## 进程与线程\n\n- 进程稳定，线程快（a little)\n- 计算密集型用 c，IO 密集型用 py。\n- 使用异步 IO 单进程单线程执行多任务。\n\n## 分布式进程\n\n- Thread or Process 优先选择 Process，可分布至多计算机\n\n```python\n# master.py for windows\n\nimport time\nimport queue\nfrom multiprocessing.managers import BaseManager\nfrom multiprocessing import freeze_support\n\n# 任务个数\ntask_number = 10\n\n# 定义收发队列\ntask_queue = queue.Queue(task_number)\nresult_queue = queue.Queue(task_number)\n\n\ndef gettask():\n    return task_queue\n\n\ndef getresult():\n    return result_queue\n\n\ndef test():\n    # windows下绑定调用接口不能使用lambda，所以只能先定义函数再绑定\n    BaseManager.register('get_task', callable=gettask)\n    BaseManager.register('get_result', callable=getresult)\n    # 绑定端口并设置验证码，windows下需要填写ip地址，linux下不填默认为本地\n    manager = BaseManager(address=('127.0.0.1', 5002), authkey=b'123')\n    # 启动\n    manager.start()\n    try:\n        # 通过网络获取任务队列和结果队列\n        task = manager.get_task()\n        result = manager.get_result()\n\n        # 添加任务\n        for i in range(task_number):\n            print('Put task %d...' % i)\n            task.put(i)\n\n        # 每秒检测一次是否所有任务都被执行完\n        while not result.full():\n            time.sleep(1)\n\n        for i in range(result.qsize()):\n            ans = result.get()\n            print('task %d is finish , runtime:%d s' % ans)\n\n    except:\n        print('Manager error')\n    finally:\n        # 一定要关闭，否则会爆管道未关闭的错误\n        manager.shutdown()\n\n\nif __name__ == '__main__':\n    # windows下多进程可能会炸，添加这句可以缓解\n    freeze_support()\n    test()\n\n```\n\n```python\n#!/usr/bin/env python3\n# -*- coding : utf-8 -*-\n# task.py for windows\n\nimport time\nimport sys\nimport queue\nimport random\nfrom multiprocessing.managers import BaseManager\n\nBaseManager.register('get_task')\nBaseManager.register('get_result')\n\nconn = BaseManager(address=('127.0.0.1', 5002), authkey=b'123')\n\ntry:\n    conn.connect()\nexcept:\n    print('连接失败')\n    sys.exit()\n\ntask = conn.get_task()\nresult = conn.get_result()\n\nwhile not task.empty():\n    n = task.get(timeout=1)\n    print('run task %d' % n)\n    sleeptime = random.randint(0, 3)\n    time.sleep(sleeptime)\n    rt = (n, sleeptime)\n    result.put(rt)\n\nif __name__ == '__main__':\n    pass\n```\n\n## 多进程\n\n- `fork()`\n\n操作系统自动复制当前进程，子进程返回 0，父进程返回子进程的 ID。\n\n```python\nimport os\n\nprint('Process (%s) start...', % os.getpid())\npid = os.fork()\t\t\t\t# Only work on Linux\n# 父子进程同时运行如下命令\nif pid == 0:\n    print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid()))\nelse:\n    print('I (%s) just created a child process (%s).' % (os.getpid(), pid))\n```\n\n- multiprocessing（翻译：多种进程）\n\n```python\nfrom multiprocessing import Process\t# windows使用多线程\nimport os\n\n# 子进程要执行的代码\ndef run_proc(name):\n    print('Run child process %s (%s)...' % (name, os.getpid())\n    # os.getppid()\t获取父进程id\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Process(target=run_proc, args=('test',))\n    # targe 函数名\n    # args 元组提供参数\n    # kwargs 字典方式传参\n    print('Child process will start.')\n    p.daemon = True\n    # 主进程结束子进程自动销毁\n    p.start()\n    p.join()\n    # join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。\n    # 等待进程执行完毕\n    print('Child process end.')\n'''\nParent process 10652.\nChild process will start.\nRun child process test (19276)...\nChild process end.\n'''\n```\n\n- Pool（进程池）\n\n```python\nfrom multiprocessing import Pool\nimport os, time, random\n\ndef long_time_task(name):\n    print('Run task %s (%s)...' % (name, os.getpid()))\n    start = time.time()\n    time.sleep(random.random() * 3)\n    end = time.time()\n    print('Task %s runs %0.2f seconds.' % (name, (end - start)))\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Pool(4)\t\t# 同时跑四个进程\n    for i in range(5):\n        p.apply_async(long_time_task, args=(i,))\n    print('Waiting for all subprocesses done...')\n    p.close()\n    # 调用join()之前必须先调用close()，会等待所有子进程执行完毕。\n    p.join()\n    print('All subprocesses done.')\n```\n\n## 子进程\n\n- 在 python 中运行命令\n\n```python\nimport subprocess\n\nprint('$ nslookup www.python.org')\nr = subprocess.call(['nslookup', 'www.python.org'])\nprint('Exit code:', r)\n```\n\n### 进程间通信\n\n- 使用`Queues`来交换数据\n\n```python\nfrom multiprocessing import Process, Queue\nimport os\nimport time\nimport random\n\n\ndef make(q):\n    print('My PID is %s and I am random a nember,Do you know it?' % os.getpid())\n    q.put(random.randint(1, 100))\n    time.sleep(3)\n\n\ndef guess(q):\n    print('My PID is %s and get the nember is %s' % (os.getpid(), q.get()))\n\n\nif __name__ == '__main__':\n    q = Queue()\n    pm = Process(target=make, args=(q,))\n    pg = Process(target=guess, args=(q,))\n    pm.start()\n    pg.start()\n    pm.join()\n    pg.join()\n\n```\n"}}]);