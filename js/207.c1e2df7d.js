(window.webpackJsonp=window.webpackJsonp||[]).push([[207],{835:function(n,t){n.exports='\x3c!--\ntitle: 08-文件操作\nsort:\n--\x3e\n\n# 文件输入输出\n\n## 标准 IO\n\n> `fopen(file, mode)`\n>\n> - rwa 读写追\n> - b 二进制\n> - \\+ 更新模式\n> - `fopen()`创建一个缓冲区，并返回指向该结构的指针。\n>\n> - **w 会删除文件中的内容**\n>\n> `getc() putc()`\n>\n> - 与`getchar() putchar()`类似。\n>\n> - `getchar()`为从标准输入中读取字符。\n>\n> - `getc(fp)`为从 fp 指定的文件中读取一个字符。\n>\n> - `putc(ch, fpput)`为把字符 ch 放入 FILE 指针`fpout`所制定的文件中\n>   由`EOP`确定一个文件是否到末尾\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv [])\n{\n    int ch;\n    // 文件指针\n    FILE *fp;\n    // 打开文件\n    if((fp = fopen(argv[1], "r")) == NULL)\n    {\n        printf("Can\'t open %s.", argv[1]);\n    }\n    // 输出内容\n    while((ch=getc(fp)) != EOF)\n        putc(ch, stdout);\n    // 关闭文件\n    if(fclose(fp) != 0 )\n    {\n        printf("Error in closing file %s\\n", argv[1]);\n    }\n}\n```\n\n## 文件 IO\n\n- `fprint/fscanf()`\n\n  > `fprint(stdout, "%s is best!", argv[1])`\n  >\n  > 打印至标准输出\n  >\n  > `fscanf(stdin, "%40s", word);`\n  >\n  > 接收输入至 word\n  >\n  > `fprintf(fp, "%s\\n", word);`\n  >\n  > 将 word 输出到文件\n  >\n  > `fprint(stderr, "Something was wrong.");`\n  >\n  > `exit()`\n  >\n  > 抛出异常\n\n- `rewind(fp)`\n\n  > 返回文件至最开始处\n\n- `fgets/puts()`\n  > 读取文件至换行符、文件结尾 EOF 或 strlen-1\n  >\n  > `fgets(receive*, strlen, FILE*)`\n  >\n  > 接受地址，长度，文件指针。\n  >\n  > 会读取换行符，放在空字符\\0 之前。\n  >\n  > `fputs(send*, FILE*)`\n  >\n  > 不添加换行符\n\n## 随机访问\n\n```c\nfseek(FILE*, Mov(L), SEEK_SET);\n/*  用于确定光标位置\n    第一个参数为文件指针，\n    第二个为偏移量（L表示值为Long），\n    第三个为起始位置：\n    SEEK_SET SEEK_CUR SEEK_END\n    文件开头    当前    文件末尾\n\n    返回值正常为0，超出文件范围则为-1。\n*/\nftell(FILE*);\n// 返回光标距离开头的字节数（适用于以二进制模式打开的情况下钱）\n```\n\n## 其他标准 IO 函数\n\n```c\n// 把一个字符放回到缓冲区\nint ungetc(int c, FILE * fp)\n// 刷新缓冲区，把缓冲区所有尚未读写的数据传入fp中\nint fflush(FILE * fp);\n// 自己建立缓冲区\n// 文件指针，缓冲区，模式，缓冲区大小\n/* mode：\n_IOFBF  完全缓冲\n_IOLBF  行缓冲\n_IONBF  无缓冲\n*/\nint setvbuf(FILE * fp, char * buf, int mode, size_t size);\n// 二进制模式存数据，浮点不丢失精度\n// 数据 类型大小 数据块数量 文件指针\nsize_t fwrite(ptr , sizeof(double), size_t nmemb, FILE * fp);\nfread(同上);\n```\n\n## 总结\n\n> `getchar() putchar(输出内容)`\n>\n> > 标准输入输出操作一个字符\n>\n> `getc(*fp) putc(ch, *fp)`\n>\n> > 文件单个字符操作\n>\n> `fgets(目的地址，长度，*fp) fputs(源地址，*fp)`\n>\n> > 操作至换行符\n>\n> `fprint(目标类型，内容) fscanf(读取位置，存储位置)`\n> printf 与 scanf 的升级版\n'}}]);