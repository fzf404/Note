(window.webpackJsonp=window.webpackJsonp||[]).push([[301],{929:function(n,t){n.exports="\x3c!--\ntitle: 31-Requests\nsort:\n--\x3e\n\n# Requests 库入门\n\n## 发送请求\n\n1. `Get`请求\n\n   ```python\n   payload = {'key1': 'value', 'key2': 'value2'}\n   r = requests.get('https://www.bilibili.com', params=payload, timeout=5)\t# 返回response对象\n   ```\n\n2. `Post`请求\n\n   这是 requests 中最重要的对象\n\n   ```python\n   payload = {'key1': 'value1', 'key2': 'value2'}\n   # 使用json\n   r = requests.post(url, json=payload)\n   # x-www-form-urlencoded格式\n   r = requests.post(\"http://httpbin.org/post\", data=payload)\n   # form-data格式\n   payload = {'key1': 'value1', 'file': open('xx.jpg','rb')}\n   r = requests.post(\"http://httpbin.org/post\", file=payload)\n   ```\n\n3. 获得内容\n\n   ```python\n   r.url\t\t\t# 请求URL\n   r.status_code\t# 状态码\n   r.status_code == requests.codes.ok\t# 查询状态码\n   r.text\t\t# 自动解码并展示html\n   r.encoding = 'utf-8'\t# 改变编码\n   r.content\t\t# 二进制格式\n   r.json()\t\t# 解析json的方法\n   r.raw\t\t\t# 原数据\n   # 将原始数据保存到文件\n   for i in r.iter_content():  # 迭代的content\n       f.write(i)\n\n   ```\n\n4. 请求头\n\n   ```python\n   url = 'https://www.bilibili.com'\n   header = {'user-agent': 'my-app/0.0.1'}\n   # 只获得请求头\n   r = requests.head(url)\n   print(r.headers)\n   ```\n\n5. 重定向\n\n   > Requests 会自动处理所有重定向。\n\n   ```python\n   r.history\t\t# 追踪重定向\n   r = requests.get(url, allow_redirects=False)\t# 拒绝重定向\n   ```\n\n## Session\n\n> 能够跨请求保持某些参数，在同一个 Session 实例发出的所有请求之间保持 cookie。\n\n1. 保持 cookie\n\n   ```python\n   s = requests.session()\n   r = s.get('http://www.baidu.com')\t\t# 获取cookie\n   print(r.cookies)\n   '''\n   <RequestsCookieJar[<Cookie BDORZ=27[3]15 for .baidu.com/>]>\n   '''\n   ```\n\n2. 传入传出 cookies\n\n   ```python\n   s = requests.Session()\n   r = s.get(\"https://www.baidu.com\")\n   # 将CookieJar转为字典：\n   cookie_dict = requests.utils.dict_from_cookiejar(r.cookies)\n   # 将字典转为CookieJar：两种方法\n   requests.utils.add_dict_to_cookiejar(s.cookies, cookie_dict)\n   s.cookies = requests.utils.cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True)\n   ```\n\n3. 提供缺省值数据\n\n   ```python\n   s = requests.Session()\n   s.auth = ('user', 'pass')\n   s.headers.update({'x-test': 'true'})\n\n   # b'x-test' and 'x-test2' 都被发送\n   r = s.get('http://httpbin.org/headers', headers={'x-test2': 'true'})\n   print(r.text)\n   '''{\n     \"headers\": {\n       \"Accept\": \"*/*\",\n       \"Accept-Encoding\": \"gzip, deflate\",\n       \"Authorization\": \"Basic dXNlcjpwYXNz\",\n       \"Host\": \"httpbin.org\",\n       \"User-Agent\": \"python-requests/2.23.0\",\n       \"X-Amzn-Trace-Id\": \"Root=1-5ed8e20e-bca4639c82a80f6e0fd6308e\",\n       \"X-Test\": \"true\",\n       \"X-Test2\": \"true\"\n     }\n   }'''\n   # 方法级别的参数不会被保留\n\n   s = requests.Session()\n\n   r = s.get('http://httpbin.org/cookies', cookies={'from-my': 'browser'})\n   print(r.text)\n   # '{\"cookies\": {\"from-my\": \"browser\"}}'\n\n   r = s.get('http://httpbin.org/cookies')\n   print(r.text)\n   # '{\"cookies\": {}}'\n   ```\n\n4. 使用前后文管理器确认退出\n\n   ```python\n   with requests.session() as s:\n       s.get('http://httpbin.org')\n   ```\n\n## 请求与响应对象\n\n- 头部信息\n\n  ```python\n  r.headers\t\t# 响应头\n  r.request.headers\t# 请求头\n  ```\n\n## SSL 证书验证\n\n- 导入本地证书\n\n  ```python\n  s = requests.Session()\n  s.verify = '/path/to/certfile'\n  # 不启用验证\n  requests.get('https://kennethreitz.org', verify=False)\n  # 使用本地证书\n  requests.get('https://kennethreitz.org', cert=('/path/client.cert', '/path/client.key'))\n  # 保持在会话中\n  s = requests.Session()\n  s.cert = '/path/client.cert'\n  ```\n\n## 响应内容工作流\n\n默认请求后，响应体立即被下载，使用`stream`参数覆盖行为\n\n```python\nrequests.get(url, stream = True)\n# 此时只有响应头被下载，链接保持\n# 使用with\nwith requests.get('http://httpbin.org/get', stream=True) as r:\n    # 在此处理响应。\n```\n\n## 上传\n\n支持流式上传\n\n```python\nwith open('massive-body') as f:\n    requests.post('http://some.url/streamed', data=f)\n```\n\n## 自定义身份验证\n\n自定义的身份验证机制作为 `requests.auth.AuthBase` 的子类来实现\n\n```python\nfrom requests.auth import AuthBase\n\nclass PizzaAuth(AuthBase):\n\n    def __init__(self, username):\n        # setup any auth-related data here\n        self.username = username\n\n    def __call__(self, r):\n        # modify and return the request\n        r.headers['X-Pizza'] = self.username\n        return r\n\nrequests.get('http://pizzabin.org/admin', auth=PizzaAuth('kenneth'))\n```\n\n## 代理\n\n```python\nrequests.get(url, proxies = {'http':'http://user:pass@127.0.0.1:8888/'})\n# 安装requests[socks]可使用sock代理\n```\n\n## HTTP 动词\n\n```python\n>>> r = requests.get('https://api.github.com/requests/kennethreitz/requests/issues/482')\n>>> r.status_code\n200\n\n>>> issue = json.loads(r.text)\n\n>>> print(issue[u'title'])\nFeature any http verb in docs\n\n>>> print(issue[u'comments'])\n3\n>>> r = requests.get(r.url + u'/comments')\n>>> r.status_code\n200\n>>> comments = r.json()\n>>> print(comments[0].keys())\t# 获取全部key\n[u'body', u'url', u'created_at', u'updated_at', u'user', u'id']\n>>> print(comments[2][u'body'])\nProbably in the \"advanced\" section\n```\n\nPATCH 一个 issue\n\n```python\n>>> from requests.auth import HTTPBasicAuth\n>>> auth = HTTPBasicAuth('fake@example.com', 'not_a_real_password')\n>>> body = json.dumps({u\"body\": u\"Sounds great! I'll get right on it once I feed my cat.\"})\n\n>>> url = u\"https://api.github.com/repos/requests/requests/issues/comments/5804413\"\n\n>>> r = requests.patch(url=url, data=body, auth=auth)\n>>> r.status_code\n200\n```\n"}}]);