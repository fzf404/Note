(window.webpackJsonp=window.webpackJsonp||[]).push([[285],{913:function(n,e){n.exports="\x3c!--\ntitle: 09-常用内置库\nsort:\n--\x3e\n\n## logging\n\n> 日志库\n\n```python\n# 日志格式化方式\nLOG_FORMAT = \"%(asctime)s - %(levelname)s - %(message)s\"\nDATE_FORMAT = \"%Y/%m/%d %H:%M\"\n\n# 配置日志文件\nlogging.basicConfig(filename='info.log', level=logging.INFO,\n                    format=config.LOG_FORMAT, datefmt=config.DATE_FORMAT)\nlogging.basicConfig(filename='warning.log', level=logging.WARNING,\n                    format=config.LOG_FORMAT, datefmt=config.DATE_FORMAT)\n\n# 写入日志\nlogging.info(f'{user_name}: {message}')\nlogging.warning(f'{user_name}: {message}')\n```\n\n## argparse\n\n> argsparse 是 python 的命令行解析的标准模块\n\n```python\nimport argparse\n\nparser = argparse.ArgumentParser(description='获取参数')\n\nparser.add_argument('file', help = \"输入文件名\")     # 输入文件\nparser.add_argument('-o', '--output')   # 输出文件\nparser.add_argument('--line', type = int, default = 80) # 输出长度\n\n# 读取\nargs = parser.parse_args()\n# 获得integers参数\nprint(args.file)\nprint(args.output)\n\n# 使用\n>>> python test.py -h\t\t# 获取帮助\n>>> python test.py ./avatar.jpg -o test --width\n```\n\n## datetime\n\n处理日期和时间的标准库\n\n- 获取当前日期和时间\n\n  ```python\n  from datetime import datetime\n  now = datetime.now()\t\t\t# 获取当前时间\n  dt = datetime(2020,2,20,20,20)\t# 自定义时间\n  ```\n\n- `datime`与`timestamp`互相转换\n\n  > 计算机中的时间：\n  >\n  > `timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00`\n  >\n  > ```python\n  > dt = datetime(2020,2,20,20,20)\n  > dt.timestamp()\n  >\n  > t = 1587212736.161311\n  > print(datetime.fromtimestamp(t))\t# 当前时间\n  > print(datetime.utcfromtimestamp(t))\t# UTC+0：00\n  > # 格式化输出\n  > datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n  > ```\n\n- 字符串转换\n\n  ```python\n  now = datetime.now()\n  datetime.strptime('2020-2-20 20:20:20', '%Y-%m-%d %H:%M:%S')\t\t# 字符串转为time\n  now.strftime('%a, %b %d %H:%M')\t# time转为字符串\n  ```\n\n- 字符串加减\n\n  ```python\n  from datetime import datetime, timedelta\n  now = datetime.now()\n  now + timedelta(hours = 10)\n  now - timedelta(weeks = 2)\n  ```\n\n- UTC 转换\n\n  ```python\n  from datetime import datetime, timedelta, timezone\n  now = datetime.now()\n  tz_utc_8 = timezero(timedelate(hours = 8))\t# 创建时区\n  dt = now.replace(tzinfo=tz_utc_8)\t# 强制设置为UTC+8\n  # 强制设为UTC+0\n  utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)\n  bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))\n  print(bj_dt)\t# 转换为北京时间\n  ```\n\n## collections\n\n许多有用的集合类\n\n- namedtuple\n\n  ```python\n  from collections import namedtuple\n  Point = namedtuple('Poin', ['x', 'y'])\t# 命名为Poin对象\n  p = Point(1, 2)\n  ```\n\n- deque\n\n  > 使用`list`插入元素很慢。\n  >\n  > `deque`是双向列表，适合用于队列和栈。\n\n  ```python\n  from collections import deque\n  q = deque([1,2,3,4,5])\n  q.append(0)\n  q.appendleft(6)\n  >>> deque([6, 1, 2, 3, 4, 5, 0])\n  ```\n\n- dafaultdict\n\n  ```python\n  from collections import defaultdict\n  dd = defaultdict(lambda: 'N/A')\n  dd['key1'] = 'abc'\n  dd['key1'] # key1存在\n  dd['key2'] # key2不存在，返回默认值\n  ```\n\n- OrderedDict\n\n  将 dict 变成有序的\n\n  ```python\n  from collections import OrderedDict\n  d = dict([('a', 1), ('b', 2), ('c', 3)])\n  # dict的Key是无序的\n  od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])\n  # OrderedDict的Key是有序的\n  OrderedDict([('a', 1), ('b', 2), ('c', 3)])\n  ```\n\n- Counter\n\n  `Counter`是一个简单的计数器，例如，统计字符出现的个数\n\n  ```python\n  >>> from collections import Counter\n  >>> c = Counter()\n  >>> for ch in 'programming':\n  ...     c[ch] = c[ch] + 1\n  ...\n  >>> c\n  Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})\n  >>> c.update('hello') # 也可以一次性update\n  >>> c\n  Counter({'r': 2, 'o': 2, 'g': 2, 'm': 2, 'l': 2, 'p': 1, 'a': 1, 'i': 1, 'n': 1, 'h': 1, 'e': 1})\n  ```\n\n  例子：\n\n  ```python\n  with open(txt, 'r') as f:\n      text = jieba.lcut(f.read())\n      for i in text:\n          c[i] = c[i]+1\n  ```\n\n## base64\n\n> 二进制转换字符串\n>\n> Base64 编码会把 3 字节的二进制数据编码为 4 字节的文本数据，长度增加 33%\n>\n> 缺编码则用=补全\n\n- 字符串转 base64\n\n  ```python\n  import base64\n  base64.b64encode(b'My name is fzf~.')\n  >>> b'TXkgbmFtZSBpcyBmemZ+Lg=='\n  base64.b64decode(b'TXkgbmFtZSBpcyBmemZ+Lg==')\n  ```\n\n## struct\n\n> 处理字节\n>\n> ```python\n> import struct\n> print(struct.pack('>I', 404))\t# 转换为字节\n> print(struct.unpack('>I', b'\\x00\\x00\\x01\\x94'))\t# 转回\n> ```\n\n- 说明\n\n  | 处理指令 | 含义             |\n  | -------- | ---------------- |\n  | I        | 四字节无符号整数 |\n  | H        | 二字节无符号整数 |\n  | c        | 一字节文字       |\n\n- 读取 bmp 文件\n\n  ```python\n  def bmp_info(path):\n      with open(path,'rb') as f:\n          data = f.read()\n      s = struct.unpack('<ccIIIIIIHH', data[0:30])\n      if s[0] == b'B':\n          return {\n              'width': s[6],\n              'height': s[7],\n              'color': s[9]\n          }\n      else:\n          return 'it not a bmp.'\n  ```\n\n## hashlib\n\n常见的摘要算法\n\n- MD5\n\n  ```python\n  import hashlib\n  \n  md5 = hashlib.md5()\n  md5.update('Use the MD5.'.encode('utf-8'))\n  print(md5.hexdigest())\n  \n  hashlib.md5('fzf'.encode('utf-8')).hexdigest()\n  ```\n\n## hmac\n\n- 标准化实现带 key 的哈希\n\n  ```python\n  import hmac\n  message = b'Hello, world!'\n  key = b'secret'\n  h = hmac.new(key, message, digestmod='MD5')\n  # 如果消息很长，可以多次调用h.update(msg)\n  >>> h.hexdigest()\n  'fa4ee7d173f2d97ee79022d1a7355bcf'\n  ```\n\n## itertools\n\n\n\n- 操作迭代对象\n\n  ```python\n  import itertools\n\n  naturals = itertools.count(1)\t\t# 全体自然数\n  ns = itertools.takewhile(lambda x: x <= 10, naturals)  # 截取有限序列\n  cyc = itertools.cycle('FZF')\t\t# 无限重复固定序列\n  rep = itertools.repeat('FZF', 5)  # 设定重复次数\n\n  ```\n\n- `chain()`\n\n  串起迭代对象：`.chain('abc','fzf')`\n\n## contextlib\n\n- `with`实现自动打开与关闭\n\n- 将`class`应用至`with`\n\n  ```python\n  class Query(object):\n  \n      def __init__(self, name):\n          self.name = name\n  \n      def __enter__(self):\n          print('Begin')\n          return self\n  \n      def __exit__(self, exc_type, exc_value, traceback):\n          if exc_type:\n              print('Error')\n          else:\n              print('End')\n  \n      def query(self):\n          print('Query info about %s...' % self.name)\n  \n  with Query('Bob') as q:\n      q.query()\n  ```\n\n### @contextmanager\n\n- 代替\n\n  ```python\n  from contextlib import contextmanager\n\n  class Query(object):\n\n      def __init__(self, name):\n          self.name = name\n\n      def query(self):\n          print('Query info about %s...' % self.name)\n\n  @contextmanager\n  def create_query(name):\n      print('Begin')\n      q = Query(name)\n      yield q\t\t\t# 把变量输出给with\n      print('End')\n\n  with create_query('Bob') as q:\n  \tq.query()\n  ```\n\n- 在某段代码后自动执行特定代码\n\n  ```python\n  @contextmanager\n  def tag(name):\n      print(\"<%s>\" % name)\n      yield\n      print(\"</%s>\" % name)\n  \n  with tag(\"h1\"):\n      print(\"hello\")\n      print(\"world\")\n  ```\n\n  代码的执行顺序是：\n\n  1. `with`语句首先执行`yield`之前的语句，因此打印出``；\n  2. `yield`调用会执行`with`语句内部的所有语句，因此打印出`hello`和`world`；\n  3. 最后执行`yield`之后的语句，打印出``。\n\n### @close\n\n若对象没有上下文可使用`closing()`转换。\n\n- close 实现\n\n  ```python\n  @contextmanager\n  def closing(thing):\n      try:\n          yield thing\n      finally:\n          thing.close()\n  ```\n\n- close 使用\n\n  ```python\n  from contextlib import closing\n  from requests import get\n  \n  with closing(get(\"https://www.baidu.com\")) as page:\n      for line in page:\n          print(line)\n  ```\n\n## urlib\n\n操作 url\n\n- Get\n\n  ```python\n  '''\n  抓取https://api.douban.com/v2/book/6781808\n  并返回响应\n  '''\n  from urllib import request\n                  `\n  with request.urlopen('http://www.csh.edu.cn/') as f:\n      data = f.read()\t\t# 获得信息\n      print('Status:', f.status, f.reason)\t# 响应代码\n      for k, v in f.getheaders():\t\t\t\t# 获得头部信息\n          print('%s: %s' % (k, v))\n      print('Data:', data.decode('gbk','ignore'))\t# 打印返回值\n  ```\n\n- 查看命令参数\n\n  ```python\n  >>> from inspect import signature\n  >>> signature(request.urlopen)\n  <Signature (url, data=None, timeout=<object object at 0x000001DDE1DF7DC0>, *, cafile=None, capath=None, cadefault=False, context=None)>\n  ```\n\n- 常用方法\n\n  | 方法      | 作用                                            |\n  | --------- | ----------------------------------------------- |\n  | info()    | 返回网页的当前环境有关信息                      |\n  | getcode() | 返回网页状态码，若为 200 则正确，若为其他则错误 |\n  | geturl()  | 返回网页的 url                                  |\n  | quote()   | 对网址进行编码                                  |\n  | unquote() | 解码                                            |\n\n### 发送 GET 请求\n\n- `Request`对象\n\n  ```python\n  from urllib import request\n  url='https://www.douban.com/search?q='\n  key=request.quote('杀死一只知更鸟')\t\t# 由于字段含有中文，需要编码\n  url_all=url+key\n  # header是一个字典，放入请求头内容\n  header={'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36'}\n  req=request.Request(url_all,headers=header)\t# 获得Requests对象\n  with request.urlopen(req) as f:\t\t\t\t# 爬取网页\n  \tdata=f.read()\n  \n  with open('./dbsearch.html','wb') as fw:# 写入文件\n  \tfw.write(data)\n  ```\n\n### 模拟登录\n\n> 使用`post`方法，只需要在`urlopen`中添加`date`字段。\n\n- bilibili\n\n  ```python\n  from urllib import request, parse\n  \n  print('Login to weibo.cn...')\n  email = input('Email or PhonNumber: ')      # 用户输入登录的邮箱名\n  passwd = input('Password: ')                # 用户输入登录的密码\n  login_data = parse.urlencode([              # 编辑登录数据，用dict类型储存，parse.urlencode将dict转为url参数\n      ('username', email),\n      ('password', passwd),\n      ('entry', 'mweibo'),\n      ('client_id', ''),\n      ('savestate', '1'),\n      ('ec', ''),\n      ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&r=http%3A%2F%2Fm.weibo.cn%2F')\n  ])\n  \n  req = request.Request('https://passport.weibo.cn/sso/login')\t# 编辑头文件\n  req.add_header('Origin', 'https://passport.weibo.cn')\n  req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')\n  req.add_header(\n      'Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&res=wel&wm=3349&r=http%3A%2F%2Fm.weibo.cn%2F')\n  \n  with request.urlopen(req, data=login_data.encode('utf-8')) as f:\n      print('Status:', f.status, f.reason)             # 返回页面执行的状态\n      for k, v in f.getheaders():                      # 得到HTTP相应的头和JSON数据\n          print('%s: %s' % (k, v))\n      print('Data:', f.read().decode('unicode_escape'))  # 得到页面信息\n  \n  ```\n\n## XML\n\n- `SAX`解析\n\n  ```python\n  from xml.parsers.expat import ParserCreate\n  #利用SAX解析XML文档牵涉到两个部分: 解析器和事件处理器\n  #解析器负责读取XML文档，并向事件处理器发送事件，如元素开始跟元素结束事件。\n  #而事件处理器则负责对事件作出响应，对传递的XML数据进行处理\n  \n  class DefualtSaxHandler(object):\n      def start_element(self,name,attrs):\n          print('sax:start_elment: %s,attrs: %s'%(name,str(attrs)))\n          #name表示节点名称，attrs表示节点属性（字典）\n      def end_element(self,name):\n          print('sax:end_element: %s'%name)\n  \n      def char_data(self,text):\n          print('sax:char_data: %s'%text)\n          #text表示节点数据\n  xml=r'''<?xml version=\"1.0\"?>\n  <ol>\n      <li><a href=\"/python\">Python</a></li>\n      <li><a href=\"/ruby\">Ruby</a></li>\n  </ol>\n  '''\n  \n  #处理器实例\n  handler=DefualtSaxHandler()\n  #解析器实例\n  parser=ParserCreate()\n  \n  #下面3为解析器设置自定义的回调函数\n  #回调函数的概念，请搜索知乎，见1.9K赞的答案\n  parser.StartElementHandler=handler.start_element\n  parser.EndElementHandler=handler.end_element\n  parser.CharacterDataHandler=handler.char_data\n  #开始解析XML\n  parser.Parse(xml)\n  #然后就是等待expat解析，\n  #一旦expat解析器遇到xml的 元素开始，元素结束，元素值 事件时\n  #会回分别调用start_element, end_element, char_data函数\n  \n  #关于XMLParser Objects的方法介绍下\n  #详见python文档：xml.parsers.expat\n  #xmlparser.StartElementHandler(name, attributes)\n  #遇到XML开始标签时调用，name是标签的名字，attrs是标签的属性值字典\n  #xmlparser.EndElementHandler(name)\n  #遇到XML结束标签时调用。\n  #xmlparser.CharacterDataHandler(data)\n  #调用时机：\n  #从行开始，遇到标签之前，存在字符，content 的值为这些字符串。\n  #从一个标签，遇到下一个标签之前， 存在字符，content 的值为这些字符串。\n  #从一个标签，遇到行结束符之前，存在字符，content 的值为这些字符串。\n  #标签可以是开始标签，也可以是结束标签。\n  \n  #为了方便理解，我已经在下面还原来解析过程，\n  #标出何时调用，分别用S：表示开始；E：表示结束；D：表示data\n  \n  如果看不明白，请配合脚本输出结果一起看\n  S<ol>C\n  C   S<li>S<a href=\"/python\">CPython</a>E</li>EC\n  C   S<li>S<a href=\"/ruby\">CRuby</a>E</li>EC\n  S</ol>E\n  ```\n\n## Struct\n\n> 读取二进制\n\n```python\nimport struct\nsource = f.read()\n# 小端+2个+int\nstruct.unpack('>4i',source)\n```\n"}}]);