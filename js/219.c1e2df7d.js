(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{847:function(n,t){n.exports='\x3c!--\ntitle: 09-常用代码片段\nsort:\n--\x3e\n\n### GoRoutine\n\n```go\nimport (\n\t"fmt"\n\t"sync"\n)\n\nfunc worker(works chan int, wg *sync.WaitGroup) {\n\tfor w := range works {\n\t\tfmt.Println(w)\n\t\twg.Done()\n\t}\n}\n\nfunc main() {\n\n\t// FIFO任务队列\n\tworks := make(chan int, 100)\n\t// GoRoutine收集\n\tvar wg sync.WaitGroup\n\n\t// 新建线程\n\tfor i := 0; i < cap(works); i++ {\n\t\tgo worker(works, &wg)\n\t}\n\t// 为线程分配任务\n\tfor i := 0; i < 1024; i++ {\n\t\twg.Add(1)\n\t\t// 新增任务\n\t\tworks <- i\n\t}\n\t// 等待线程执行\n\twg.Wait()\n\t// 关闭所有任务\n\tclose(works)\n}\n\n```\n\n### 大文件读取\n\n```go\nimport (\n\t"fmt"\n\t"io"\n\t"log"\n\t"os"\n\t"time"\n)\n\n// 测试用例\nvar bigFilePath string = `/home/demo.rar`\nvar writeFilePath string = `/home/result.rar`\n\n// 分片读取\nfunc readBlock(openFilePath string, writeFilePath string) {\n\t// 开始时间\n\tstart := time.Now()\n\n\t// 打开文件\n\topenFileHandle, err := os.Open(openFilePath)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\t// 创建文件\n\twriteFileHandle, err := os.Create(writeFilePath)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tdefer openFileHandle.Close()\n\tdefer writeFileHandle.Close()\n\n\t// 设置每次读取字节数\n\tbuffer := make([]byte, 4096)\n\n\t// 循环读取处理\n\tfor {\n\t\tn, err := openFileHandle.Read(buffer)\n\t\t// 控制条件,根据实际调整\n\t\tif err != nil && err != io.EOF {\n\t\t\tlog.Println(err)\n\t\t}\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t\t// 对该分片的操作(保存到新文件\n\t\tn, err = writeFileHandle.Write(buffer)\n\t\tif err != nil {\n\t\t\tfmt.Println("编码错误", err.Error())\n\t\t\treturn\n\t\t}\n\t}\n\tfmt.Println("readBolck spend : ", time.Now().Sub(start))\n}\n\nfunc main() {\n\treadBlock(bigFilePath, writeFilePath)\n}\n```\n'}}]);