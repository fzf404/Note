(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{692:function(n,e){n.exports="\x3c!--\ntitle: Three.js\nsort:\n--\x3e\n\n## 步骤\n\n1. 创建摄像机\n2. 新建场景\n3. 增加光照\n4. 创建物体\n5. 创建材质\n6. 动起来\n\n### HelloWorld\n\n> 创建一个立方体\n>\n> [预览](https://threejsfundamentals.org/threejs/threejs-fundamentals-with-light.html)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n\n<body>\n  <canvas id=\"demo\"></canvas>\n  <script src=\"https://cdn.jsdelivr.net/npm/three\"><\/script><\/script>\n  <script>\n    function main() {\n      const canvas = document.querySelector('#demo');\n      const renderer = new THREE.WebGLRenderer({ canvas });\n      // 摄像机参数\n      const fov = 75;     // 视野范围75°\n      const aspect = 2;   // 画布宽高比\n      const near = 0.1;   // 可视最近距离\n      const far = 5;      // 可视最远距离\n      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n      // 相机默认在坐标原点，先Z轴正方向移动2，即可看到原点图像\n      camera.position.z = 2;\n      // 新建场景\n      const scene = new THREE.Scene();\n      // 光照效果\n      {\n        const color = 0xFFFFFF;\n        const intensity = 1;\n        const light = new THREE.DirectionalLight(color, intensity);\n        light.position.set(-1, 2, 4);\n        scene.add(light);\n      }\n      // 创建盒子\n      const boxWidth = 1;\n      const boxHeight = 1;\n      const boxDepth = 1;\n      const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);\n\n      // 创建材质\n      const material = new THREE.MeshPhongMaterial({ color: 0x44aa88 });  // greenish blue\n\n      // 创建一个网格对象\n      const cube = new THREE.Mesh(geometry, material);\n      scene.add(cube);\n\n      // 动起来\n      function render(time) {\n        time *= 0.001;  // 毫秒转换为秒\n\n        cube.rotation.x = time;\n        cube.rotation.y = time;\n        // 重新渲染新一帧\n        renderer.render(scene, camera);\n        requestAnimationFrame(render);\n      }\n      requestAnimationFrame(render);\n    }\n\n    main();\n  <\/script>\n</body>\n\n</html>\n```\n\n### 材质\n\n```js\n// 贴图\nconst material = new THREE.MeshPhongMaterial({\n  map: new THREE.TextureLoader().load(\"logo.jpg\"),\n});\n\n// 透明材质\nconst material = new THREE.MeshPhongMaterial({\n  side: THREE.DoubleSide, // 双边渲染\n  transparent: true, // 是否透明\n  map: new THREE.TextureLoader().load(\"logo.png\"),\n  alphaTest: 0.1, // alpha通道小于0.1的像素点不显示\n});\n```\n\n### 物体创建\n\n```js\n// 批量创建物体\nfunction makeInstance(geometry, color, x) {\n  const material = new THREE.MeshPhongMaterial({ color });\n  const cube = new THREE.Mesh(geometry, material);\n  scene.add(cube);\n  cube.position.x = x;\n  return cube;\n}\nconst cubes = [\n  makeInstance(geometry, 0x44aa88, 0),\n  makeInstance(geometry, 0x8844aa, -2),\n  makeInstance(geometry, 0xaa8844, 2),\n];\n```\n\n### 跟随鼠标旋转\n\n```js\n// 滚动参数\nlet targetRotationX = 0;\nlet targetRotationY = 0;\n// 鼠标点击时的角度状态\nlet targetRotationXOnMouseDown = 0;\nlet targetRotationYOnMouseDown = 0;\nlet mouseX = 0, mouseY = 0;\n// 距窗口中心线的位置\nlet mouseXOnMouseDown = 0;\nlet mouseYOnMouseDown = 0;\n// 窗口半长宽\nlet windowHalfX = window.innerWidth / 2;\nlet windowHalfY = window.innerHeight / 2;\n\n// 触摸事件处理\nfunction onDocumentTouchStart(event) {\n  if (event.touches.length === 1) {\n    mouseXOnMouseDown = event.touches[0].pageX - windowHalfX;\n    mouseYOnMouseDown = event.touches[0].pageY - windowHalfY;\n    targetRotationXOnMouseDown = targetRotationX;\n    targetRotationYOnMouseDown = targetRotationY;\n  }\n}\nfunction onDocumentTouchMove(event) {\n  if (event.touches.length == 1) {\n    mouseX = event.touches[0].pageX - windowHalfX;\n    mouseY = event.touches[0].pageY - windowHalfY;\n    targetRotationX = targetRotationXOnMouseDown + (mouseX - mouseXOnMouseDown\n    targetRotationY = targetRotationYOnMouseDown + (mouseY - mouseYOnMouseDown\n  }\n}\n\n// 鼠标点击事件\nfunction onDocumentMouseDown(event) {\n  document.addEventListener('mousemove', onDocumentMouseMove, false);\n  document.addEventListener('mouseup', onDocumentMouseUp, false);\n  document.addEventListener('mouseout', onDocumentMouseOut, false);\n  // 求鼠标相对窗口中线的位置\n  mouseXOnMouseDown = event.clientX - windowHalfX;\n  mouseYOnMouseDown = event.clientY - windowHalfY;\n  // 保存当前角度值\n  targetRotationXOnMouseDown = targetRotationX;\n  targetRotationYOnMouseDown = targetRotationY;\n}\n// 鼠标移动事件\nfunction onDocumentMouseMove(event) {\n  mouseX = event.clientX - windowHalfX;\n  mouseY = event.clientY - windowHalfY;\n  targetRotationX = targetRotationXOnMouseDown + (mouseX - mouseXOnMouseDown)\n  targetRotationY = targetRotationYOnMouseDown + (mouseY - mouseYOnMouseDown)\n}\n// 鼠标抬起事件\nfunction onDocumentMouseUp(event) {\n  document.removeEventListener('mousemove', onDocumentMouseMove, false);\n  document.removeEventListener('mouseup', onDocumentMouseUp, false);\n  document.removeEventListener('mouseout', onDocumentMouseOut, false);\n}\n// 鼠标移开事件\nfunction onDocumentMouseOut(event) {\n  document.removeEventListener('mousemove', onDocumentMouseMove, false);\n  document.removeEventListener('mouseup', onDocumentMouseUp, false);\n  document.removeEventListener('mouseout', onDocumentMouseOut, false);\n}\n// 鼠标滚轮事件\nfunction onDocumentMouseWheel(event) {\n  if (event.wheelDelta > 0) {   //当滑轮向上滚动时\n    fov -= (minFov < fov ? 2 : 0);\n  }\n  else {   // 当滑轮向下滚动时\n    fov += (fov < far ? 2 : 0);\n  }\n  // 改变fov值，更新场景渲染\n  camera.fov = fov;\n  camera.updateProjectionMatrix();\n  renderer.render(scene, camera);\n}\n\ndocument.addEventListener('mousedown', onDocumentMouseDown, false);\ndocument.addEventListener('mousewheel', onDocumentMouseWheel, false);\ndocument.addEventListener('touchstart', onDocumentTouchStart, false);\ndocument.addEventListener('touchmove', onDocumentTouchMove, false);\n\n// 渲染场景和相机\nfunction render(time) {\n  cube.rotation.y += 0.006\n  targetRotationX += 0.006\n  // cube.rotation.x += 0.01\n  // targetRotationY += 0.01\n  cube.rotation.y += (targetRotationX - cube.rotation.y) * 0.01; // 旋转\n  cube.rotation.x += (targetRotationY - cube.rotation.x) * 0.01;\n  renderer.render(scene, camera);\n  requestAnimationFrame(render);\n}\nrequestAnimationFrame(render);\n```\n"}}]);