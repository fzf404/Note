(window.webpackJsonp=window.webpackJsonp||[]).push([[284],{912:function(n,t){n.exports="\x3c!--\ntitle: 09-常用内置函数\nsort:\n--\x3e\n\n# 常用内置函数\n\n## 数字相关\n\n### 1. 数据类型\n\n- bool : 布尔型(True,False)\n- int : 整型(整数)\n- float : 浮点型(小数)\n- complex : 复数\n\n### 2. 进制转换\n\n- bin() 将给的参数转换成二进制\n- otc() 将给的参数转换成八进制\n- hex() 将给的参数转换成十六进制\n\n```python\nprint(bin(10))  # 二进制:0b1010\nprint(hex(10))  # 十六进制:0xa\nprint(oct(10))  # 八进制:0o12\n```\n\n### 3. 数学运算\n\n- abs() 返回绝对值\n- divmode() 返回商和余数\n- round() 四舍五入\n- pow(a, b) 求 a 的 b 次幂, 如果有三个参数. 则求完次幂后对第三个数取余\n- sum() 求和\n- min() 求最小值\n- max() 求最大值\n\n```python\nprint(abs(-2))  # 绝对值:2\nprint(divmod(20,3)) # 求商和余数:(6,2)\nprint(round(4.50))   # 五舍六入:4\nprint(round(4.51))   # 5\nprint(pow(10,2,3))  # 如果给了第三个参数. 表示最后取余:1\nprint(sum([1,2,3,4,5,6,7,8,9,10]))  # 求和:55\nprint(min(5,3,9,12,7,2))  # 求最小值:2\nprint(max(7,3,15,9,4,13))  # 求最大值:15\n```\n\n## 数据结构相关\n\n### 1. 序列\n\n（1）列表和元组\n\n- list() 将一个可迭代对象转换成列表\n- tuple() 将一个可迭代对象转换成元组\n\n```python\nprint(list((1,2,3,4,5,6)))  # [1, 2, 3, 4, 5, 6]\nprint(tuple([1,2,3,4,5,6]))  # (1, 2, 3, 4, 5, 6)\n```\n\n（2）相关内置函数\n\n- reversed() 将一个序列翻转, 返回翻转序列的迭代器\n- slice() 列表的切片\n\n```python\nlst = \"你好啊\"\nit = reversed(lst)   # 不会改变原列表. 返回一个迭代器, 设计上的一个规则\nprint(list(it))  # ['啊', '好', '你']\nlst = [1, 2, 3, 4, 5, 6, 7]\nprint(lst[1:3:1])  # [2,3]\ns = slice(1, 3, 1)  #  切片用的\nprint(lst[s])  # [2,3]\n```\n\n（3）字符串\n\n- str() 将数据转化成字符串\n\n```python\nprint(str(123)+'456')  #123456\n```\n\n- format() 与具体数据相关, 用于计算各种小数, 精算等.\n\n```python\ns = \"hello world!\"\nprint(format(s, \"^20\"))  #剧中\nprint(format(s, \"<20\"))  #左对齐\nprint(format(s, \">20\"))  #右对齐\n#     hello world!\n# hello world!\n#         hello world!\nprint(format(3, 'b' ))    # 二进制:11\nprint(format(97, 'c' ))   # 转换成unicode字符:a\nprint(format(11, 'd' ))   # ⼗进制:11\nprint(format(11, 'o' ))   # 八进制:13\nprint(format(11, 'x' ))   # 十六进制(⼩写字母):b\nprint(format(11, 'X' ))   # 十六进制(大写字母):B\nprint(format(11, 'n' ))   # 和d⼀样:11\nprint(format(11))         # 和d⼀样:11\nprint(format(123456789, 'e' ))      # 科学计数法. 默认保留6位小数:1.234568e+08\nprint(format(123456789, '0.2e' ))   # 科学计数法. 保留2位小数(小写):1.23e+08\nprint(format(123456789, '0.2E' ))   # 科学计数法. 保留2位小数(大写):1.23E+08\nprint(format(1.23456789, 'f' ))     # 小数点计数法. 保留6位小数:1.234568\nprint(format(1.23456789, '0.2f' ))  # 小数点计数法. 保留2位小数:1.23\nprint(format(1.23456789, '0.10f'))  # 小数点计数法. 保留10位小数:1.2345678900\nprint(format(1.23456789e+3, 'F'))   # 小数点计数法. 很大的时候输出INF:1234.567890\n```\n\n- bytes() 把字符串转化成 bytes 类型\n\n```python\nbs = bytes(\"今天吃饭了吗\", encoding=\"utf-8\")\nprint(bs)  #b'\\xe4\\xbb\\x8a\\xe5\\xa4\\xa9\\xe5\\x90\\x83\\xe9\\xa5\\xad\\xe4\\xba\\x86\\xe5\\x90\\x97'\n```\n\n- bytearray() 返回一个新字节数组. 这个数字的元素是可变的, 并且每个元素的值得范围是[0,256)\n\n```python\nret = bytearray(\"alex\" ,encoding ='utf-8')\nprint(ret[0])  #97\nprint(ret)  #bytearray(b'alex')\nret[0] = 65  #把65的位置A赋值给ret[0]\nprint(str(ret))  #bytearray(b'Alex')\n```\n\n- ord() 输入字符找出字符编码的位置\n- chr() 输入位置数字找出对应的字符\n- ascii() 是 ascii 码中的返回该值 不是就返回 u\n\n```python\nprint(ord('a'))  # 字母a在编码表中的码位:97\nprint(ord('中'))  # '中'字在编码表中的位置:20013\nprint(chr(65))  # 已知码位,求字符是什么:A\nprint(chr(19999))  # 丟\n\nfor i in range(65536):  # 打印出0到65535的字符\n    print(chr(i), end=\" \")\n\nprint(ascii(\"@\"))  #'@'\n```\n\n- repr() 返回一个对象的 string 形式\n\n```python\ns = \"今天\\n吃了%s顿\\t饭\" % 3\nprint(s)\n# 今天\n# 吃了3顿    饭\nprint(repr(s))   # 原样输出,过滤掉转义字符 \\n \\t \\r 不管百分号%\n#'今天\\n吃了3顿\\t饭'\n```\n\n### 2. 数据集合\n\n- 字典：dict 创建一个字典\n- 集合：set 创建一个集合\n\nfrozenset() 创建一个冻结的集合，冻结的集合不能进行添加和删除操作。\n\n### 3. 相关内置函数\n\n- len() 返回一个对象中的元素的个数\n- sorted() 对可迭代对象进行排序操作 (lamda)\n\n语法：sorted(Iterable, key=函数(排序规则), reverse=False)\n\n- Iterable: 可迭代对象\n- key: 排序规则(排序函数), 在 sorted 内部会将可迭代对象中的每一个元素传递给这个函数的参数. 根据函数运算的结果进行排序\n- reverse: 是否是倒叙. True: 倒叙, False: 正序\n\n```python\nlst = [5,7,6,12,1,13,9,18,5]\nlst.sort()  # sort是list里面的一个方法\nprint(lst)  # [1, 5, 5, 6, 7, 9, 12, 13, 18]\n\nll = sorted(lst) # 内置函数. 返回给你一个新列表  新列表是被排序的\nprint(ll)  # [1, 5, 5, 6, 7, 9, 12, 13, 18]\n\nl2 = sorted(lst,reverse=True)  #倒序\nprint(l2)  # [18, 13, 12, 9, 7, 6, 5, 5, 1]\n\n#根据字符串长度给列表排序\nlst = ['one', 'two', 'three', 'four', 'five', 'six']\ndef f(s):\n    return len(s)\nl1 = sorted(lst, key=f, )\nprint(l1)  # ['one', 'two', 'six', 'four', 'five', 'three']\n```\n\n- enumerate() 获取集合的枚举对象\n\n```python\nlst = ['one','two','three','four','five']\nfor index, el in enumerate(lst,1):    # 把索引和元素一起获取,索引默认从0开始. 可以更改\n    print(index)\n    print(el)\n# 1\n# one\n# 2\n# two\n# 3\n# three\n# 4\n# four\n# 5\n# five\n```\n\n- all() 可迭代对象中全部是 True, 结果才是 True\n- any() 可迭代对象中有一个是 True, 结果就是 True\n\n```python\nprint(all([1,'hello',True,9]))  #True\nprint(any([0,0,0,False,1,'good']))  #True\n```\n\n- zip()\n\n  > 将对象中对应的元素打包成一个元组，然后返回由这些元组组成的列表。\n  >\n  > 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同\n\n```python\nlst1 = [1, 2, 3, 4, 5, 6]\nlst2 = ['醉乡民谣', '驴得水', '放牛班的春天', '美丽人生', '辩护人', '被嫌弃的松子的一生']\nlst3 = ['美国', '中国', '法国', '意大利', '韩国', '日本']\nprint(zip(lst1, lst1, lst3))  # <zip object at 0x00000256CA6C7A88>\nfor el in zip(lst1, lst2, lst3):\n    print(el)\n# (1, '醉乡民谣', '美国')\n# (2, '驴得水', '中国')\n# (3, '放牛班的春天', '法国')\n# (4, '美丽人生', '意大利')\n# (5, '辩护人', '韩国')\n# (6, '被嫌弃的松子的一生', '日本')\n```\n\n- fiter() 过滤 (lamda)\n\n  > 语法：fiter(function. Iterable)\n  >\n  > function: 用来筛选的函数. 在 ﬁlter 中会自动的把 iterable 中的元素传递给 function. 然后根据 function 返回的 True 或者 False 来判断是否保留留此项数据 , Iterable: 可迭代对象\n\n```python\ndef func(i):    # 判断奇数\n    return i % 2 == 1\nlst = [1,2,3,4,5,6,7,8,9]\nl1 = filter(func, lst)  # l1是迭代器\nprint(l1)  # <filter object at 0x000001CE3CA98AC8>\nprint(list(l1))  # [1, 3, 5, 7, 9]\n```\n\n- map() 会根据提供的函数对指定序列列做映射(lamda)\n\n  > 语法 : map(function, iterable)\n\n可以对可迭代对象中的每一个元素进行映射. 分别去执行 function\n\n```python\ndef f(i):\n  return i\n  lst = [1,2,3,4,5,6,7,]\nit = map(f, lst) # 把可迭代对象中的每一个元素传递给前面的函数进行处理. 处理的结果会返回成迭代器print(list(it))  # [1, 2, 3, 4, 5, 6, 7]\n```\n\n## 和作用域相关\n\n- locals() 返回当前作用域中的名字\n- globals() 返回全局作用域中的名字\n\n```python\ndef func():\n    a = 10\n    print(locals())  # 当前作用域中的内容\n    print(globals())  # 全局作用域中的内容\n    print(\"今天内容很多\")\nfunc()\n# {'a': 10}\n# {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__':\n# <_frozen_importlib_external.SourceFileLoader object at 0x0000026F8D566080>,\n# '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins'\n# (built-in)>, '__file__': 'D:/pycharm/练习/week03/new14.py', '__cached__': None,\n#  'func': <function func at 0x0000026F8D6B97B8>}\n# 今天内容很多\n```\n\n## 和迭代器生成器相关\n\n- range() 生成数据\n- next() 迭代器向下执行一次, 内部实际使用了** next**()方法返回迭代器的下一个项目\n- iter() 获取迭代器, 内部实际使用的是** iter**()方法来获取迭代器\n\n```python\nfor i in range(15,-1,-5):\n    print(i)\n# 15\n# 10\n# 5\n# 0\nlst = [1,2,3,4,5]\nit = iter(lst)  #  __iter__()获得迭代器\nprint(it.__next__())  #1\nprint(next(it)) #2  __next__()\nprint(next(it))  #3\nprint(next(it))  #4\n```\n\n## 字符串类型代码的执行\n\n- eval() 执行字符串类型的代码. 并返回最终结果\n- exec() 执行字符串类型的代码\n- compile() 将字符串类型的代码编码. 代码对象能够通过 exec 语句来执行或者 eval()进行求值\n\n```python\ns1 = input(\"请输入a+b:\")  #输入:8+9\nprint(eval(s1))  # 17 可以动态的执行代码. 代码必须有返回值\ns2 = \"for i in range(5): print(i)\"\na = exec(s2) # exec 执行代码不返回任何内容\n\n# 0\n# 1\n# 2\n# 3\n# 4\nprint(a)  #None\n\n# 动态执行代码\nexec(\"\"\"\ndef func():\n    print(\" 我是周杰伦\")\n\"\"\" )\nfunc()  #我是周杰伦\n\ncode1 = \"for i in range(3): print(i)\"\ncom = compile(code1, \"\", mode=\"exec\")   # compile并不会执行你的代码.只是编译\nexec(com)   # 执行编译的结果\n# 0\n# 1\n# 2\n\ncode2 = \"5+6+7\"\ncom2 = compile(code2, \"\", mode=\"eval\")\nprint(eval(com2))  # 18\n\ncode3 = \"name = input('请输入你的名字:')\"  #输入:hello\ncom3 = compile(code3, \"\", mode=\"single\")\nexec(com3)\nprint(name)  #hello\n```\n\n## 输入输出\n\n- print() : 打印输出\n- input() : 获取用户输出的内容\n\n```python\nprint(\"hello\", \"world\", sep=\"*\", end=\"@\") # sep:打印出的内容用什么连接,end:以什么为结尾\n#hello*world@\n```\n\n## 内存相关\n\n- hash() : 获取到对象的哈希值(int, str, bool, tuple). hash 算法:(1) 目的是唯一性 (2) dict 查找效率非常高, hash 表.用空间换的时间 比较耗费内存\n\n```python\ns = 'alex'\nprint(hash(s))  #-168324845050430382\nlst = [1, 2, 3, 4, 5]\nprint(hash(lst))  #报错,列表是不可哈希的\n  id() :  获取到对象的内存地址\ns = 'alex'\nprint(id(s))  #2278345368944\n```\n\n## 文件操作相关\n\n- open() : 用于打开一个文件, 创建一个文件句柄\n\n```python\nf = open('file',mode='r',encoding='utf-8')\nf.read()\nf.close()\n```\n\n## 模块相关\n\n** import**() : 用于动态加载类和函数\n\n```python\n# 让用户输入一个要导入的模块\nimport os\nname = input(\"请输入你要导入的模块:\")\n__import__(name)    # 可以动态导入模块\n```\n\n## 帮助\n\n- help() : 函数用于查看函数或模块用途的详细说明\n\n```python\nprint(help(str))  #查看字符串的用途\n```\n\n## 调用相关\n\n- callable() : 用于检查一个对象是否是可调用的. 如果返回 True, object 有可能调用失败, 但如果返回 False. 那调用绝对不会成功\n\n```python\na = 10\nprint(callable(a))  #False  变量a不能被调用\n#\ndef f():\n    print(\"hello\")\n    print(callable(f))   # True 函数是可以被调用的\n```\n\n## 查看内置属性\n\n- dir() : 查看对象的内置属性, 访问的是对象中的**dir**()方法\n\n```python\nprint(dir(tuple))  #查看元组的方法\n```\n"}}]);