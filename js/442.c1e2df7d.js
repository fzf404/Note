(window.webpackJsonp=window.webpackJsonp||[]).push([[442],{1070:function(n,e){n.exports='\x3c!--\ntitle: 26-JS面向对象\nsort:\n--\x3e\n\n> 对象`object`是一个容器，封装了属性`property`和方法`method`\n\n## 构造函数\n\n> 用于生成实例对象的函数\n\n```js\nvar Salefzf = function (price) {\n  // 判断是否使用new\n  if (!new.target) {\n    throw new Error("请使用 new 命令调用！");\n  }\n  if (price > 10) {\n    this.sale_status = true;\n  } else {\n    this.sale_status = false;\n  }\n};\n\n// 使用new创建实例: 空对象赋值给构造函数中的this变量，运行构造函数\nvar buy = new Salefzf(20);\nbuy.sale_status;\ntrue;\n\n// 创建实例对象\nvar buy2 = Object.create(buy);\nbuy2.sale_status;\ntrue;\n```\n\n### this\n\n> `this`就是属性或方法“当前”所在的对象。\n\n```js\n// 指向可变\nvar A = {\n  name: "张三",\n  describe: function () {\n    return "姓名：" + this.name;\n  },\n};\n\nvar B = {\n  name: "李四",\n};\n\nB.describe = A.describe;\nB.describe();\n// "姓名：李四"\n```\n\n## 对象的继承\n\n> 构造函数的多个实例中方法不共享\n\n```js\n// 共享属性\nfunction Animal(name) {\n  this.name = name;\n}\n// 原型函数\nAnimal.prototype.color = "white";\n\nvar cat1 = new Animal("大毛");\nvar cat2 = new Animal("二毛");\n\ncat1.color; // \'white\'\ncat2.color; // \'white\'\n\nAnimal.prototype.walk = function () {\n  console.log(this.name + " is walking");\n};\ncat1.walk();\n// 大毛 is walking\n```\n\n### 构造函数的继承\n\n```js\n// 构造函数\nfunction Animal() {\n  this.live = true;\n  this.age = 0;\n}\n\nAnimal.prototype.update_age = function (age) {\n  if (age > 18) {\n    this.live = false;\n    console.log("Death!");\n  }\n};\n\n// 测试\na1 = new Animal();\na1.live; // true\nal.update_age(20);\na1.live; // false\n\n// 继承\n// 第一步，子类继承父类的实例\nfunction Dog() {\n  Animal.call(this);\n}\n\ndog1 = new Dog();\ndog1.age; // 0\ndog1.update_age(20); // undefined\n\n// 第二步，子类继承父类的原型\n// 拷贝方法\nRectangle.prototype = Object.create(Shape.prototype);\nRectangle.prototype.constructor = Rectangle;\n\ndog1 = new Dog();\ndog1.update_age(20); // Death\n```\n'}}]);