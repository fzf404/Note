(window.webpackJsonp=window.webpackJsonp||[]).push([[213],{841:function(n,t){n.exports='\x3c!--\ntitle: 02-Go进阶\nsort:\n--\x3e\n\n## 函数\n\n```go\n// 先于 main 执行\n// 每个包、源文件都可以有多个 init 函数\nfun init(){}\n\n// 凶残的匿名函数\nwriteDataFn := func() {\n  var data []int // 往 slice 里 写100 个数；\n  for i := 0; i < 100; i++ {\n   data = append(data, i)\n  }\n  atomic.StorePointer(&shareBufPtr, unsafe.Pointer(&data)) // 写完后，将共享缓存的指针指向它；\n }\n\n readDataFn := func() {\n  data := atomic.LoadPointer(&shareBufPtr)\n  fmt.Println(data, *(*[]int)(data)) // 打印共享缓存里的值\n }\n```\n\n\n\n## 接口\n\n> 将不同类型中相同的方法定义在一起\n\n```go\npackage main\n\nimport "fmt"\n\n// 定义接口 内部两个方法\ntype Phone interface {\n    call(param int) string\n    takephoto()\n}\n\n// 结构体实例\ntype Xiaomi struct {}\n\n// 为Xiaomi定义call方法\nfunc (mi Xiaomi) call(param int) string{\n    fmt.Println("I\'m Xioami, Calling: ", param)\n    return "Hang up..."\n}\n\nfunc (mi Xiaomi) takephoto() {\n    fmt.Println("I take a photo.")\n}\n\nfunc main(){\n    // 新建接口\n    var phone Phone\n    // 接口获得一个结构体\n    phone = new(Xiaomi)\n    // 调用结构体接口的方法\n    phone.takephoto()\n    // 调用带参数的方法\n    r := phone.call(404)\n    fmt.Println(r)\n}\n/*\nI take a photo.\nI\'m Xioami:  404\nI\'m death\n*/\n```\n\n### 断言\n\n```go\n// 中间件将用户信息写入上下文\nc.Set("user", &user)\n// 获得用户信息\nuser, _ := c.Get("user")\n// 断言 interface{} 用 model.User 解析\nuser.(*model.User).UserName\n```\n\n## 线程\n\n```go\nfunc main() {\n    go running(1)\n    fmt.Println("Main Running...")\n    time.sleep(2*time.Second)\n}\n\nfunc running(id int) {\n    fmt.Println(id, " Running...")\n    time.sleep(1*time.Second)\n}\n\n// 通道\nfunc main() {\n\tc := make(chan int)\n  go running(1, c)\n    runningID := <-c\n\t// 无需sleep\n}\n\nfunc running(id int, c chan int) {\n    fmt.Println(" Running...")\n    time.sleep(1*time.Second)\n    c <- id\n}\n// 使用select抛弃超时的通道\nfunc main() {\n\tc := make(chan int)\n\n    go running(1, c)\n\n    timeout := time.After(2 * time.Second)\n    select {\n    \tcase runningID := <-c:\n            fmt.Println(runningID ," finish")\n        case <- timeout:\n            fmt.Println(runningID ," T")\n    }\n\n\t// 无需sleep\n}\n```\n'}}]);