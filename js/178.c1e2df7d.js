(window.webpackJsonp=window.webpackJsonp||[]).push([[178],{806:function(n,l){n.exports="\x3c!--\ntitle: 03-跳出MBR\nsort:\n--\x3e\n\n> 效果图\n\n![image-20210101230624929](https://img-1257284600.cos.ap-beijing.myqcloud.com/2020/20210108154733.png)\n\n```assembly\nNumSector equ 4     ; 软盘最大扇区编号\nNumHeader equ 0\nNumCylind equ 0\n\nMBRseg equ 7c0h \t; 启动扇区段地址\nOUTseg equ 800h \t; 跳出启动扇区地址\n\njmp start\n\n; Message全局变量定义\nmsg_welcome:\n    db '--** Welcome To fzfOS **--','$'\nmsg_setp1:\n    db 'Setp 1: MBR','$'\nmsg_Mem:\n    db 'Value of ','$'\nmsg_CS:\n    db 'CS:????H','$'\nmsg_Load:\n    db 'Loading Code...','$'\n\ncylind db 'cylind:?? $',0   ; 柱面\nheader db 'header:?? $',0   ; 磁头\nsector db 'sectpy:?? $',2   ; 扇区\nfyOK db 'Read OK','$'\nfyError db 'Read Error' ,'$'\n\nstart:\n    call inMBR\n    call floppyLoad\n    jmp OUTseg:0    ; 跳出MBR\n\ninMBR:\n    ; 初始化数据段寄存器\n    mov ax, MBRseg\n    mov ds, ax\n    ; 为读数据到软盘做准备\n    mov ax, OUTseg\n    mov es, ax      ; 读软盘需要ES:BX\n\n    call inMBRShow\n    call showCS\n    call newLine\n    call newLine\n    call showLoad\n    ret\n\ninMBRShow:\n    mov si, msg_welcome\n    call printStr\n    call newLine\n    call newLine\n    mov si, msg_setp1\n    call printStr\n    call newLine\n    mov si, msg_Mem\n    call printStr\n    ret\n\nshowLoad:\n    mov si, msg_Load\n    call printStr\n    call newLine\n    ret\n\nprintStr:\n    ; 将字符拷贝到al\n    mov al, [si]\n    ; 判断是否末尾\n    cmp al, '$'\n    je over\n    ; 设置10H中断的服务：在Teletype模式下显示字符\n    mov ah, 0eh\n    ; BIOS对显示器和屏幕所提供的服务程序\n    int 10h\n    ; 递增si的值\n    inc si\n    ; 递归\n    jmp printStr\nover:\n    ret\n\n; 新的一行\nnewLine:\n    mov ah, 0eh\n    mov al, 0dh\n    int 10h\n    mov al, 0ah\n    int 10h\n    ret\n\nshowCS:\n    ; 将CS值放入ax\n    mov ax, cs\n\n    ; 高8位放入dl中, 解析后放入bx\n    mov dl, ah\n    call Hex2Bit\n\n    ; cs高4位移到dl\n    mov dl, bh\n    call ASCII\n    mov [msg_CS+3], dl\n\n    ; cs高-4位\n    mov dl, Bl\n    call ASCII\n    mov [msg_CS+4], dl\n\n    mov dl,al\n    call Hex2Bit\n    mov dl, bh\n    call ASCII\n    mov  [msg_CS+5], dl\n\n    mov dl, bl\n    call ASCII\n    mov  [msg_CS+6], dl\n\n    mov si, msg_CS\n    call printStr\n    ret\n\n; 一比特十六进制转为ASCII\nASCII:\n    cmp dl,9\n    ; 大于9则去LETTER\n    jg LETTER\n    ; 小于9直接+30h及为对应ASCII\n    add dl,30h\n    ret\n\nLETTER:\n    add dl,37H\n    ret\n\n; 取Byte的高/低4位,IN_DL,OUT_BH+BL\nHex2Bit:\n    ; CS的高8位挪到dh\n    mov dh, dl\n    ; CS的高8位挪到bl\n    mov bl, dl\n    ; dh右移4位，只剩高4位CS值\n    SHR dh,1\n    SHR dh,1\n    SHR dh,1\n    SHR dh,1\n    ; CS高4位移到bh\n    mov bh, dh\n    ; CS低4位移到bl\n    and bl, 0fh\n    ; bx 0101 CS 1100\n    ret\n\n\n; -------- 读扇区 --------\nfloppyLoad:\n    call readSector\n    mov ax, es\n    add ax, 0x0020\n    mov es, ax      ; 一扇区512B, 200h\n    inc byte [sector+11]    ; 扇区加1\n    cmp byte [sector+11], NumSector+1\n    jne floppyLoad\n    ; 下一个磁头\n    mov byte [sector+11], 1\n    inc byte [header+11]\n    cmp byte [header+11],NumHeader+1\n    jne floppyLoad\n    ; 下一个柱面\n    mov byte [header+11],0\n    inc byte [cylind+11]\n    cmp byte [cylind+11],NumCylind+1\n    jne floppyLoad\n\n    ret\n\n; 数字转ASCII 传入cl\nnum2ascii:\n    mov ax, 0\n    mov al, cl\n    mov bl, 10\n    div bl  ; ax/bl 结果->ah 余数->al\n    add ax, 3030h\n    ret\n\nreadInfo:\n    mov si, cylind\n    call printStr\n    mov si, header\n    call printStr\n    mov si, sector\n    call printStr\n    ret\n\nreadSector:     ; 解析读取位置\n\n    mov cl, [sector+11]\n    ; 将数字转换成ASCII，替换掉？\n    call num2ascii\n    mov   [sector+7],al\n    mov   [sector+8],ah\n\n    mov cl, [header+11]\n    call num2ascii\n    mov   [header+7],al\n    mov   [header+8],ah\n\n    mov cl, [cylind+11]\n    call num2ascii\n    mov   [cylind+7],al\n    mov   [cylind+8],ah\n\n    ; 设置读取\n    mov ch, [cylind+11]\n    mov dh, [header+11]\n    mov cl, [sector+11]\n\n    ; 显示信息\n    call readInfo\n    ; 记录读取错误次数\n    mov di, 0\n\nretry:\n\n    mov ah, 02h ; AH0x02表示读取磁盘\n    mov al, 1   ; 读取的扇区数\n    mov bx, 0   ; ES:BX 读到内存的地址 0x0800*16 + 0 = 0x8000\n    mov dl, 0   ; 驱动器号，表示第一个软盘\n    int 13h     ; 调用bios13号中断，磁盘相关功能\n    jnc ReadOK  ; CF=0表示为未出错，则跳转ReadOK\n    inc di      ; 错误则递增\n\n    mov ah, 0   ; 设置为重置驱动器\n    mov dl, 0   ; 还是第一个软盘\n    int 13h     ; 重置驱动器\n    cmp di, 5\n    jne retry   ; 再次尝试读取\n\n    mov si, fyError     ; 错误处理\n    call printStr\n    call newLine\n    jmp exitRead\n\nReadOK:\n    mov     si, fyOK\n    call    printStr\n    call    newLine\n\nexitRead:\n    ret\n\ntimes 510-($-$$) db 0\ndb 0x55,0xaa\n\n; -------- 第二扇区分割线 --------\n\njmp    nextProgram\n\nmsg_setp2:\n    db 'Setp 2: JMP OUT MBR','$'\nmsg_Mem2:\n    db 'Value of ','$'\nmsg_CS2:\n    db 'CS:????H','$'\n\nnextProgram:\n    ; 跳转后使用新的地址段\n    mov ax, OUTseg\n    mov ds, ax\n    mov es, ax\n    call outMBR\n    call showCS2\n    jmp $       ;死循环\n\noutMBR:\n    call newLine2\n    call newLine2\n    ; ds已经加200h,msg需要减去512字节\n    mov  si, msg_setp2-512\n    call printStr2\n    call newLine2\n    mov  si, msg_Mem2-512\n    call printStr2\n    ret\n\nshowCS2:\n    ; 将CS值放入ax\n    mov ax, cs\n\n    ; 高8位放入dl中, 解析后放入bx\n    mov dl, ah\n    call Hex2Bit2\n\n    ; cs高4位移到dl\n    mov dl, bh\n    call ASCII2\n    mov [msg_CS2+3-512], dl\n\n    ; cs高-4位\n    mov dl, bl\n    call ASCII2\n    mov [msg_CS2+4-512], dl\n\n    mov dl,al\n    call Hex2Bit2\n    mov dl, bh\n    call ASCII2\n    mov  [msg_CS2+5-512], dl\n\n    mov dl, bl\n    call ASCII2\n    mov  [msg_CS2+6-512], dl\n\n    ; 显示\n    mov si, msg_CS2-512\n    call printStr2\n    ret\n\nprintStr2:\n    ; 将字符拷贝到al\n    mov al, [si]\n    ; 判断是否末尾\n    cmp al, '$'\n    je over2\n    ; 设置10H中断的服务：在Teletype模式下显示字符\n    mov ah, 0eh\n    ; BIOS对显示器和屏幕所提供的服务程序\n    int 10h\n    ; 递增si的值\n    inc si\n    ; 递归\n    jmp printStr2\n\nover2:\n    ret\n\n; 新的一行\nnewLine2:\n    mov ah, 0eh\n    mov al, 0dh\n    int 10h\n    mov al, 0ah\n    int 10h\n    ret\n; 一比特十六进制转为ASCII\nASCII2:\n    cmp dl,9\n    ; 大于9则去LETTER\n    jg LETTER2\n    ; 小于9直接+30h及为对应ASCII\n    add dl,30h\n    ret\n\nLETTER2:\n    add dl,37H\n    ret\n\n; 取Byte的高/低4位,IN_DL,OUT_BH+BL\nHex2Bit2:\n    ; CS的高8位挪到dh\n    mov dh, dl\n    ; CS的高8位挪到bl\n    mov bl, dl\n    ; dh右移4位，只剩高4位CS值\n    SHR dh,1\n    SHR dh,1\n    SHR dh,1\n    SHR dh,1\n    ; CS高4位移到bh\n    mov bh, dh\n    ; CS低4位移到bl\n    and bl, 0fh\n    ; bx 0101 CS 1100\n    ret\n\n```\n"}}]);