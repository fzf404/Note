(window.webpackJsonp=window.webpackJsonp||[]).push([[452],{1080:function(n,e){n.exports='\x3c!--\ntitle: 42-TypeScript入门\nsort:\n--\x3e\n\n## 类型断言\n\n```typescript\nlet str: any = "fzf404";\n// 告诉编译器, 你不要帮我们检查了, 相信我，它就是这个类型。\nlet len = (str as string).length;\nconsole.log(len);\n```\n\n## 泛型\n\n> 用来弥补 any 没有语法提示和报错的缺点。\n>\n> 最开始不指定类型，后面根据我们传入的类型确定类型。\n\n```typescript\nlet getArray = <T>(value: T, items: number = 5): T[] => {\n  return new Array(items).fill(value);\n};\n\nlet arr = getArray<string>("abc");\n\nlet arr = getArray("abc");\n\nlet res = arr.map((item) => item.length);\n\nconsole.log(res);\n```\n\n## 声明文件\n\n> 声明类型的部分单独抽离成一个声明文件\n\n```typescript\ndeclare let myName: string;\n\ndeclare function say(name: string, age: number): void;\n// 注意点: 声明中不能出现实现\n\ndeclare class Person {\n  name: string;\n  age: number;\n  constructor(name: string, age: number);\n  say(): void;\n}\n\ninterface Man {\n  name: string;\n  age: number;\n}\n```\n\n## 模块\n\n### 导入导出\n\n```typescript\n// 无需命名\nexport default function (s: string) {\n  return s.length;\n}\n// 导入时指定名称\nimport strLen from "./len";\n\n// 导出时重命名\nexport { strLen as getLen };\n\n// 导入时重命名\nimport { getLen as strLen } from "./len";\n```\n\n### 命名空间\n\n> 程序内部代码，使用命名空间封装和防止全局污染\n\n```typescript\nnamespace Validation {\n  const lettersRegexp = /^[A-Za-z]+$/;\n\n  export const LettersValidator = (value) => {\n    return lettersRegexp.test(value);\n  };\n}\n// 外部使用\nconsole.log(Validation.LettersValidator("abc"));\n```\n'}}]);